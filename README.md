# tonejs-json-sequencer

[Japanese README](README.ja.md) / [English README](README.md)

[Demo](https://cat2151.github.io/tonejs-json-sequencer/src/index.html)

# Current Status
- Frequent breaking changes are expected.
- This document and related documents may contain AI-generated content, and plans may be incorrect (different from cat2151's original concept).

# 3-line explanation
- A lightweight library that allows you to describe Tone.js timbres, effects, and performances in JSON.
- Control sound with data without writing code, enabling seamless integration with UI and streaming.
- Handle time-ordered events as data, allowing for intricate performance expressions.

# Why
* This section was hastily generated by ChatGPT and may be rewritten in the future.
* In reality, most of this is "planned for future implementation."

Tone.js is a library that enables rich musical expression on the web. It allows for advanced sound design in JavaScript, including building synthesizers, effect chains, and scheduling triggers.

However, due to its flexibility, the structure of timbres and patterns can easily become deeply embedded in the program, making reuse and integration difficult.

tonejs-json-sequencer is a small mechanism that leverages Tone.js while externalizing timbre definitions, performance content, and timing information as JSON, enabling data-driven music playback.

The sequence is structured like an SMF (Standard MIDI File): "all events explicitly arranged in chronological order."

Timbres can be flexibly defined in JSON using Tone.js's synth/chain/params.

Dynamic changes to timbre parameters are possible during playback, allowing for performance expressions like delayed vibrato or filter sweeps.

Directly receives NDJSON streams from external tools or live generation engines, enabling real-time playback.

This simply enables the manipulation, playback, and exchange of structured musical data via UI or over a network on Tone.js.

# Design Philosophy
* This section was hastily generated by ChatGPT and may be rewritten in the future.

tonejs-json-sequencer takes the approach of describing Tone.js components (synths, effect chains, parameter changes, etc.) directly in JSON.

It does not introduce its own music description language or abstraction layers; instead, such higher-level logic is entrusted to higher program layers.

Timbre definitions specify constructor names like Tone.Synth or Tone.FMSynth and their argument objects.

Event definitions also have a structure similar to Tone.js calls, such as triggerAttackRelease.

Parameter changes during playback are listed with function names, arguments, and event timestamps.

This achieves the goal of moving playback logic to data and making it externally configurable, without compromising Tone.js's sonic expressive power.

The core `scheduleOrExecuteEvent` is a simple source file that only accepts a single element, with sequencing and NDJSON streaming handled by higher layers.

This allows for flexible and separated development of the low-level connection to Tone.js and higher-level features like sequencing and streaming.

# JSON Support for Tone.js Components

tonejs-json-sequencer enables the description of key Tone.js components in JSON.

## Overview of Support Status

### Currently Supported (‚úÖ)

- **Instrument**: Synth, MonoSynth, FMSynth, AMSynth, DuoSynth, MetalSynth, MembraneSynth, PluckSynth, NoiseSynth, PolySynth, Sampler
- **Effect**: Reverb, Freeverb, JCReverb, Chorus, Phaser, Tremolo, Vibrato, AutoFilter, AutoPanner, AutoWah, FeedbackDelay, PingPongDelay, Distortion, BitCrusher, Chebyshev, PitchShift, FrequencyShifter, StereoWidener

### Planned (üöß)

- **Source**: FatOscillator, PulseOscillator
- **Effect**: EQ3 (Equalizer), Compressor
- **Performance Methods**: Panpot change, Expression change, LPF change, Portamento

### Under Consideration (‚è≥)

- **Source**: Oscillator, OmniOscillator, Noise, Player, GrainPlayer, etc.
- **Effect**: Filter types, Dynamics types (Limiter, Gate), Spatial types (Convolver), etc.
- **Component**: Envelope types, LFO, Signal types, Analysis types (Meter, Analyser, FFT), etc.

## Detailed Documentation

For detailed support status, implementation priorities, and policies for all components, please refer to the following document:

üìÑ [Tone.js Component JSON Support Roadmap (Detailed Version)](docs/tonejs-components-roadmap.ja.md)

This document includes the following information:
- Classification and implementation status of all components (Instrument / Source / Effect / Component)
- Implementation priorities and plans
- Implementation policy and progress
- Links to reference materials

# Roadmap
* Order is not fixed.
* Later, it might be good to split into two types: a simple sample focused on a single topic for ease of use, and a practical sample combining multiple topics to clearly demonstrate strengths.
- Program
  - NDJSON streaming, details to be described later
- Structure
  - Done: Multitimbral, FM Bass, and Saw Chord
- Performance Techniques
  - Done: Delayed vibrato
  - Pitch envelope: changes from -200 cents at attack to 0 cents * Not linked to attack, but independent like delayed vibrato.
  - Sequence phrase to change Panpot LR on the fly
  - Phrase to increase/decrease Expression on the fly
  - Phrase to increase/decrease LPF on the fly
- Effect
  - Reverb
  - Chorus
  - Delay
  - Phaser, applying a long sweep to a synth pad; if impossible, make it clear in the title, etc.
  - EQ
  - Compressor
- Lead
  - Done: SuperSaw timbre (FatOscillator)
  - Distortion, preferably a guitar sound with PluckSynth
  - Overdrive-like WaveShaper settings, preferably a guitar sound with PluckSynth
  - Extreme synth lead using Chebyshev
  - FM lead with long decay and harmonic changes, glittering typical FM lead; try pulse for modulator and carrier; if impossible, make it clear in the title, etc.
  - Ambient lead, pulse timbre, randomly subtle pitch variations
  - Idiosyncratic lead, attack-linked pitch envelope: changes from -200 cents at attack to 0 cents.
  - Lead with constant portamento
- Sequence Timbres
  - PulseOscillator timbre, 12.5% pulse
  - PluckSynth timbre, acoustic guitar or harp
  - Playing a melodic phrase with NoiseSynth by applying a filter
- Drum
  - Tone.js built-in Kick, Snare, Tom, Hi-Hat; if 909 Kick is not possible, make it clear in the title, etc.
- Pad
  - Done: Thick synth pad with FatOscillator
  - FM Electric Piano
- Bass
  - Hard FM Bass
  - Synth bass with a constantly active attack-linked filter envelope
  - Overdrive-like Saw synth bass, with filter envelope, and filter changing with a long sweep
- Other Tone.js samples that clearly demonstrate sound will be added as notable ones are found. As of now, the above concludes this section.

# Development Notes, Updated As Needed
- Integration with tonejs-mml-to-json
  - Postpone. Will consider after organizing tonejs-json-sequencer's validation data.
- NDJSON streaming
  - Goals
    - Live editing: when a textarea is edited, the changes should be reflected while playback continues, not by replaying.
    - Loop playback: when the end is reached, playback restarts from the beginning.
  - Method
    - NDJSON streaming of events to be played within the next 50ms from now.
    - Set 50ms after the "play" button is pressed as 0-tick. Thereafter, in the sequencer, process event timestamps by adding +50ms. Add more during loops.
    - Expected to be split into a separate HTML and source file.
- Do not use Tone.Transport.schedule yet.
  - When I tried having an agent generate code for it, complex code was produced, but no improvement in unnatural sound production was observed.
  - It is premature; decided it's better to wait until test data is ready.
  - Future Outlook
    - Implement the higher layer (tonejs-mml-to-json).
    - Create test data.
      - JSON that clearly shows rhythmic "wobble" (lack of precision).
        - E.g., high-tempo phrases with arpeggios, chords, and bass.
    - Perform the following:
      - Play that JSON with tonejs-json-sequencer and confirm the "wobble."
      - Implement Tone.Transport.schedule and test for "wobble" improvement.
      - Implement and test a proven method successful with postmate-midi:
        - Process JSON time descriptions in a higher layer to specify real-time, then play via NDJSON streaming.
        - As mentioned, specify +50ms in the future.

# Issues Under Consideration
- Problem: Manually writing switch-case statements is cumbersome.
  - Policy: Writing actual function calls with switch-case is safe and simple, so we plan to stick with this.
    - Concern: However, if the switch-case grows large, there's a concern about excessive communication speed, despite the lightweight library concept.
      - Assumption: Therefore, a mechanism to only use function names in a whitelist is an option, but it would increase complexity and the risk of security errors.
        - Postpone: This is a non-functional requirement, so it's better to consider it after dogfooding and deeming it "too slow."
  - Analysis: Insufficient context for an agent to generate switch-case statements.
    - E.g., it's unclear if `depth.rampTo` etc. can be fully covered by generation.
    - E.g., whether `depth.rampTo` is sufficient as is, and what other method chains exist for other performance techniques or timbres, requires dogfooding.
    - Assumption: Even if full coverage could be generated, investigating during test red would be cumbersome (due to the vast source code).
  - Countermeasure: Maintain the current implementation policy and proceed with dogfooding.
- Consideration of a timbre library
  - * This might eventually be split into a separate project, similar to tonejs-mml-to-json.
  - Past Issues
    - It's unclear what the full potential of Tone.js is in terms of sound output when mastered.
      - Mastering, here, means within the scope of low-cost implementation, without external waveforms (soundfonts, etc.) or external AudioWorklets.
      - For example, for Saw and Square waves, the actual timbre characteristics, presence of aliasing noise in high frequencies, and usefulness for FM connections are still unknown due to lack of investigation.
        - (For reference, according to ChatGPT, though unverified) Tone.js reportedly generates a waveform table for one loop during node creation, leading to aliasing noise around the Nyquist frequency at high frequencies.
      - For example, FM:
        - Since it uses frequency modulation instead of phase modulation and lacks feedback,
        - timbres based on phase modulation or feedback cannot be produced, but
        - the potential for what waveforms can be used for modulators and carriers and what timbres can be produced is still unknown due to lack of investigation.
      - For example, SuperSaw:
        - How much additional effort, such as effects, would be needed to
        - create a practical, typical SuperSaw?
        - A clearer roadmap and workflow for this would be beneficial.
      - For example, to create a 64-sample, 8-bit waveform for 1 loop, Tone.js and Web Audio do not provide such an interface. The only way is likely to perform a Fourier transform to generate partials parameters (if more is needed, external waveforms or AudioWorklets are the only options), but
        - whether this is actually the case is still unknown due to lack of investigation.
      - For example, for Reverb / Chorus / Flanger / Phaser, it's still unknown due to insufficient investigation whether at least SC-88Pro level quality can be achieved.
      - For example, for Distortion types, including Overdrive, it's still unknown due to insufficient investigation whether at least SC-88Pro level quality can be achieved.
      - Since the use case is "use with limitations. For educational, experimental purposes," not being able to produce luxurious sounds is not critical.
        - What's important is to understand "what is possible? Where is the sweet spot?" to enable smoother musical activities.
        - To elaborate, Tone.js and Web Audio are positioned more towards simple signal processing than instruments. Understanding this, there's also the perspective of what can be achieved with low-cost instrument-like tasks, given these limitations.
        - Here, "low-cost" refers to the idea of "if the tech stack and ecosystem like tonejs-json-sequencer grow rich, will future users be able to stand on the shoulders of giants and develop at low cost?"
        - It is understood that Tone.js is superior in overall capabilities as an option.
        - In other words, when choosing the browser as a free, open-source, multi-platform environment for musical activities, Tone.js is recognized as superior in overall capability.
  - Countermeasures
    - If timbre library sharing becomes easy,
      - the potential that can be realized with low-cost methods is about this much,
      - and this will become easier to visualize.
  - Image
    - Share examples such as: "You can create these timbres, apply these effects, and combine them to produce practical sounds of this quality."
  - Benefits of a timbre library
    - It is expected to form the foundation of the Tone.js ecosystem.
        - A previous challenge has been the lack of reusability of each user's output.
        - If an environment for sharing and collaborating on individual user outputs is established, its accumulation can enable future users to stand on the shoulders of giants.
          - This applies not only to timbres but to Web Audio in general.
  - Consideration of the timbre library's layer
    - Not integrated into tonejs-json-sequencer,
    - but provided in a higher layer, as a separate project.
  - How much focus on the timbre library?
    - Under consideration.
    - If both a timbre library and a timbre editor are well-developed, the ecosystem is likely to thrive.
    - Developing minimum functionality for tonejs-json-sequencer has high priority.
      - Because the existence of functionality in tonejs-json-sequencer is a prerequisite for higher layers.
- Related to "Why": Distinction from DAWs
  - DAW
    - For prioritizing song completeness.
    - For maximizing composition/arrangement efficiency.
    - High-quality songs can be created quickly! Maximum practicality!
    - Required non-functional app requirements: low latency, no audio dropouts. Assumes use of high-performance machines.
  - tonejs-json-sequencer
    - * Or more broadly, non-DAW music apps in browsers, WebAudio, Tone.js, and multi-platform environments.
    - For experimentation:
      - New UIs
      - New sounds, timbres, and songs with new methods.
    - New experiences:
      - Inspiration for songwriting.
    - Interactive experiences:
      - E.g., educational music toys.
    - No specific non-functional requirements.
      - Quick feature implementation is desirable.
      - Multi-platform compatibility is desirable.

# Priorities
- Implementation of features with clear effects. E.g., delayed vibrato, multitimbral.
- Safety. Security. Injection countermeasures. Avoid using eval, etc.

# Out of Scope
- Node ID assignment ‚Üí Handled by higher layers, e.g., tonejs-mml-to-json or a JSON post-processor at a lower layer.
- Generating delayed vibrato on/off for all notes ‚Üí Same as node ID assignment.
- Other data processing within JSON ‚Üí Same as node ID assignment.
- Exhaustive coverage. Completely covering all combinations of Tone.js classes, methods, and method chains, and all patterns of function calls achievable with Tone.js via JSON.
- High performance. Choosing hard-to-maintain logic to minimize processing time or source file size.

# Automatic English Translation
README.md is automatically generated from README.ja.md using Gemini's translation via GitHub Actions.