# tonejs-json-sequencer

[Japanese README](README.ja.md) / [English README](README.md)

[Demo](https://cat2151.github.io/tonejs-json-sequencer/src/index.html)

# 3-Line Summary
- A lightweight library that allows describing Tone.js timbres, effects, and performances in JSON.
- Controls sound with data instead of code, enabling natural integration with UIs and streaming.
- Treats time-ordered events as data, allowing for intricate performance expressions.

# Why
* This section was quickly generated by ChatGPT. It may be rewritten in the future.
* Actually, most of this is "planned for future implementation."

Tone.js is a library that enables rich musical expression on the web. It allows for advanced audio design, such as building synthesizers, effect chains, and scheduling triggers, all freely in JavaScript.

However, due to its flexibility, the structure of timbres and patterns can easily become deeply embedded in the program, making reuse and integration difficult.

tonejs-json-sequencer is a small mechanism that leverages Tone.js while externalizing timbre definitions, performance content, and timing information as JSON, enabling data-driven music playback.

Sequences are structured like SMF, "explicitly arranging all events in chronological order."

Timbres can be flexibly defined in JSON using Tone.js's synth/chain/params.

Timbre parameters can be dynamically changed even during playback, allowing for performance expressions like delayed vibrato and filter opening/closing.

It can directly receive NDJSON streams from external tools or live generation engines, enabling real-time playback.

This simplifies the process of manipulating, playing back, and exchanging structured music data via UI or network on Tone.js.

# Design Philosophy
* This section was quickly generated by ChatGPT. It may be rewritten in the future.

tonejs-json-sequencer takes an approach of directly describing Tone.js components (synths, effect chains, parameter changes, etc.) in JSON.

It avoids introducing its own music description language or abstraction layers, delegating such high-level logic to higher program layers.

Timbre definitions specify constructor names like `Tone.Synth` or `Tone.FMSynth` and their argument objects.

Event definitions also have a structure similar to Tone.js calls, such as `triggerAttackRelease`.

Parameter changes during playback are listed with function names, arguments, and event timestamps.

This achieves the goal of moving playback logic to data, making it externally configurable, without compromising Tone.js's audio expressive power.

The core `scheduleOrExecuteEvent` is a simple source file that only accepts a single element, with higher layers handling sequencing and NDJSON streaming.

This allows for flexible, separate development of low-level layers connected to Tone.js and high-level layers like sequencing and streaming.

# JSON Support for Tone.js Components

tonejs-json-sequencer enables the description of key Tone.js components using JSON.

## Overview of Support Status

### Currently Supported (‚úÖ)

- **Instrument**: Synth, MonoSynth, FMSynth, AMSynth, DuoSynth, MetalSynth, MembraneSynth, PluckSynth, NoiseSynth, PolySynth, Sampler
- **Effect**: Reverb, Freeverb, JCReverb, Chorus, Phaser, Tremolo, Vibrato, AutoFilter, AutoPanner, AutoWah, FeedbackDelay, PingPongDelay, Distortion, BitCrusher, Chebyshev, PitchShift, FrequencyShifter, StereoWidener

### Planned (üöß)

- **Source**: FatOscillator, PulseOscillator
- **Effect**: EQ3 (Equalizer), Compressor
- **Performance Methods**: Panpot changes, Expression changes, LPF changes, Portamento

### Under Consideration (‚è≥)

- **Source**: Oscillator, OmniOscillator, Noise, Player, GrainPlayer, etc.
- **Effect**: Filter-related, Dynamics-related (Limiter, Gate), Spatial-related (Convolver), etc.
- **Component**: Envelope-related, LFO, Signal-related, Analysis-related (Meter, Analyser, FFT), etc.

## Detailed Documentation

For detailed support status, implementation priorities, and policies for all components, please refer to the following document:

üìÑ [Tone.js Component JSON Support Roadmap (Detailed Version)](docs/tonejs-components-roadmap.ja.md)

This document includes the following information:
- Classification and implementation status of all components (Instrument / Source / Effect / Component)
- Implementation priorities and plans
- Implementation policy and process
- Links to reference materials

# Roadmap
* Not in order of priority
* Eventually, it would be good to split into two types: a simple sample focused on one topic for ease of use, and a practical sample combining multiple topics to highlight strengths.
- Program
    - NDJSON streaming, details described later
- Structure
    - Done: Multitimbral, FM Bass, and Saw Chord
- Performance Techniques
    - Done: Delayed Vibrato
    - Pitch envelope: -200 cents at attack, then changes to 0 cents * (not attack-linked, but independent like delayed vibrato)
    - Sequence phrase that changes Panpot LR on the fly
    - Phrase that increases/decreases Expression on the fly
    - Phrase that increases/decreases LPF on the fly
- Effect
    - Reverb
    - Chorus
    - Delay
    - Phaser: Apply a long sweep to a synth pad. If not possible, make it clear in the title or elsewhere.
    - EQ
    - Compressor
- Lead
    - Done: SuperSaw timbre (FatOscillator)
    - Distortion, preferably guitar with Pluck
    - Overdrive-like WaveShaper settings, preferably guitar with Pluck
    - Radical synth lead using Chebyshev
    - FM lead with long decay and harmonic changes, glittering typical FM lead, try pulse for modulator and carrier. If not possible, make it clear in the title or elsewhere.
    - Ambient lead, pulse timbre, randomly subtle pitch changes
    - Unique lead with attack-linked pitch envelope: -200 cents at attack, then changes to 0 cents.
    - Lead with constant Portamento
- Sequence Timbres
    - PulseOscillator timbre with 12.5% pulse
    - PluckSynth timbre for acoustic guitar or harp
    - Play a melodic phrase with NoiseSynth by applying a filter.
- Drum
    - Tone.js built-in Kick, Snare, Tom, Hi-Hat. If a 909 Kick is not possible, make it clear in the title or elsewhere.
- Pad
    - Done: Thick synth pad with FatOscillator
    - FM Electric Piano
- Bass
    - Hard FM Bass
    - Synth bass with a constant attack-linked filter envelope
    - Overdrive-like Saw synth bass, with a filter envelope and a long filter sweep.
- Other Tone.js samples that clearly demonstrate sound will be added as they are found. For now, the above completes this section.

# Development Notes, Regularly Updated
- Integration with tonejs-mml-to-json
    - Postponed. Will consider after organizing tonejs-json-sequencer's validation data.
- NDJSON streaming
    - What we want to achieve:
        - Live editing: When a textarea is edited, the changes are reflected while playback continues, instead of replaying from the beginning.
        - Loop playback: Play from the beginning when the end is reached.
    - Method:
        - NDJSON streaming of events to be played within the next 50msec from now.
        - Set 50msec after the play button start time as 0 tick, then in the sequencer, process event timestamps by adding +50msec. Add further during loops.
        - Assumed to be separated into a different HTML and different src file.
- Do not use `Tone.Transport.schedule` yet.
    - When I tried generating code with an agent, it produced complex code, but no improvement in the unnaturalness of the sound could be confirmed.
    - Decided it's premature; it's better to wait until test data is available.
    - Future prospects:
        - Implement the higher layer (tonejs-mml-to-json).
        - Create test data:
            - JSON where rhythmic sloppiness is clearly noticeable.
                - E.g., high-tempo phrases with arpeggios, chords, and bass.
        - Perform the following:
            - Play that JSON with tonejs-json-sequencer and confirm the sloppiness.
            - Implement `Tone.Transport.schedule` and test for sloppiness improvement.
            - Implement and test the successful method from postmate-midi:
                - Process JSON time descriptions in the higher layer to specify real time and play with NDJSON streaming.
                - As mentioned above, specify +50msec into the future.

# Issues Under Consideration
- Issue: Manually writing switch cases is cumbersome.
    - Policy: We plan to stick with writing actual function calls in switch cases, as it's safe and simple.
        - Concern: However, if the switch case grows large in the future, there's a concern about excessive communication speed for a lightweight library.
            - Assumption: Therefore, we will also consider a mechanism that only uses function names on a whitelist, although this increases complexity and the risk of security errors.
                - Postponed: This is a non-functional requirement, so it's better to consider it after dogfooding reveals it's "too slow."
    - Analysis: Insufficient context for an agent to generate switch cases.
        - E.g., it's unclear if `depth.rampTo` can be covered by generation.
        - E.g., it's unclear if `depth.rampTo` is sufficient as is, and what other method chains exist for other playing styles or timbres; dogfooding is required.
        - Assumption: Even if all coverage could be generated, investigating during a test red state would be cumbersome (due to the enormous source code).
    - Solution: Continue with the current implementation policy and proceed with dogfooding.
- Consideration of a Timbre Library
    * This might eventually be extracted as a separate project proposal, similar to tonejs-mml-to-json.
    - Past Issues:
        - The potential of Tone.js, i.e., how much sound it can actually produce when mastered, is unclear.
            - "Mastered" here means within the scope of low-cost implementation, without external waveforms (soundfonts, etc.) or external AudioWorklets.
            - For example, for Saw and Square, the actual timbre characteristics, presence of aliasing noise in high frequencies, and usefulness for FM connections are yet to be investigated and are currently unknown.
                - For reference, according to ChatGPT (caution: unverified), Tone.js generates a waveform table for one loop during node creation, and aliasing noise apparently occurs around the Nyquist frequency at high frequencies.
            - For example, FM:
                - Since it uses frequency modulation instead of phase modulation and has no feedback,
                - it cannot produce phase modulation-based timbres or feedback-based timbres, but
                - the potential of what waveforms can be used for modulators and carriers and what timbres can be produced is yet to be investigated and is currently unknown.
            - For example, SuperSaw:
                - How much additional effort, such as effects, is needed to create
                - a practical, typical SuperSaw?
                - A clearer roadmap and workflow would be beneficial.
            - For example, to create a 1-loop, 64-sample, 8-bit waveform, there's no interface for it within Tone.js or Web Audio, and probably the only way is to use Fourier transform to generate partials parameters (if more is needed, only external waveforms or AudioWorklets can be used). This seems to be the case, but
                - whether this is actually true is yet to be investigated and is currently unknown.
            - For example, for Reverb / Chorus / Flanger / Phaser, whether at least the level of an SC-88Pro can be achieved is yet to be investigated and is currently unknown due to insufficient research.
            - For example, for Distortion effects, including Overdrive, whether at least the level of an SC-88Pro can be achieved is yet to be investigated and is currently unknown due to insufficient research.
            - Since the purpose is "compromised use: educational, experimental," the inability to produce luxurious sounds is not particularly fatal.
                - What's important is that seeing "how much it can achieve? Where is the sweet spot?" would enable smoother musical activities.
                - To clarify, Tone.js and WebAudio are positioned more towards simple signal processing than musical instruments. Understanding this, there's also the perspective of how much can be achieved with low-cost "instrument-like" functionality by making compromises.
                - "Low-cost" here means "can development be done at low cost by building upon the shoulders of giants in the future, if the technology stack and ecosystem soil like tonejs-json-sequencer become rich?"
                - It is recognized that Tone.js is superior in overall capabilities among the options.
                - In other words, when choosing the browser as a platform for free, open-source, multi-platform musical activities, Tone.js is recognized as superior in overall capabilities.
    - Solution:
        - If timbre library sharing becomes easy,
            - the potential that can be realized with low-cost methods will be more visible.
            - will become easier to visualize.
    - Image:
        - Share examples of "this is the kind of timbre you can create," "these are the effects you can apply," and "combining them yields this practical sound."
    - Benefits of a Timbre Library:
        - It is expected to become the foundation of the Tone.js ecosystem.
            - A past issue is the lack of reusability of each user's output.
            - If a foundation for sharing and collaborating on each user's output is established, its accumulation can enable future users to stand on the shoulders of giants.
                - This applies not only to timbres but to Web Audio in general.
    - Consideration of the Timbre Library's Layer:
        - Not to be integrated into tonejs-json-sequencer,
        - but to be prepared in a higher layer, a separate project.
    - How much focus to put on the Timbre Library?
        - Under consideration.
        - If both the timbre library and timbre editor are well-developed, the ecosystem is likely to grow more easily.
        - The priority is high to build minimum functionality into tonejs-json-sequencer.
            - Because having functionality in tonejs-json-sequencer is a prerequisite for higher layers.
- Related to Why: Differentiating from DAWs
    - DAW
        - For prioritizing song completeness.
        - For maximizing composition and arrangement efficiency.
        - High-quality songs can be created quickly! Maximum practicality!
        - Required non-functional app requirements: low latency, no audio dropouts. Assumes use of high-performance machines.
    - tonejs-json-sequencer
        * Or more generally, non-DAW music apps on browsers, WebAudio, Tone.js, multi-platform.
        - For experimentation:
            - New UIs
            - New sounds, timbres, and songs using new methods.
        - New experiences:
            - Inspiration for composition.
        - Interactive experiences:
            - E.g., educational music toys.
        - No required non-functional requirements.
            - Quick implementation of features is desirable.
            - Being multi-platform is desirable.

# Priorities
- Implement things with clear effects. E.g., delayed vibrato, multitimbral.
- Safety. Security. Injection countermeasures. Do not use `eval`, etc.

# Out of Scope
- Node ID assignment ‚Üí Handled by the higher layer, e.g., tonejs-mml-to-json or a lower-layer JSON post-processor.
- Generating delay vibrato on and off for all notes ‚Üí Same as node ID assignment.
- Other data processing within JSON ‚Üí Same as node ID assignment.
- Exhaustiveness. Completely covering all combinations of Tone.js classes, methods, and method chains, and all patterns of function calls achievable with Tone.js via JSON.
- High performance. Choosing hard-to-maintain logic to minimize processing time or source file size.

# Automatic English Translation
README.md is automatically generated from README.ja.md via Gemini's translation in GitHub Actions.