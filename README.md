# tonejs-json-sequencer

<p align="left">
  <a href="README.ja.md"><img src="https://img.shields.io/badge/üáØüáµ-Japanese-red.svg" alt="Japanese"></a>
  <a href="README.md"><img src="https://img.shields.io/badge/üá∫üá∏-English-blue.svg" alt="English"></a>
</p>

[Demo](https://cat2151.github.io/tonejs-json-sequencer/demo/index.html)

# Status
- Frequent breaking changes are expected.
- This document and related documents may contain AI-generated content, and plans may be incorrect (differing from cat2151's original concept).

# In 3 Lines
- A lightweight library that allows describing Tone.js timbres, effects, and performances in JSON.
- Control sound with data without writing code, enabling seamless integration with UIs and streaming.
- Treat time-ordered events as data, allowing for intricate musical expressions.

# Why
* This section was hastily generated by ChatGPT and may be rewritten in the future.
* In reality, most of this is "planned for future implementation."

Tone.js is a library that enables rich musical expression on the web. It allows for advanced audio design in JavaScript, including building synths, effect chains, and scheduling triggers.

However, due to its flexibility, the structure of timbres and patterns can easily become deeply embedded in the code, making reuse and integration challenging.

tonejs-json-sequencer is a small mechanism that leverages Tone.js while externalizing timbre definitions, performance content, and timing information as JSON, enabling data-driven music playback.

Sequences have a structure like SMF (Standard MIDI File): "all events explicitly arranged in chronological order."

Timbres can be flexibly defined in JSON using Tone.js's synth/chain/params.

Dynamic changes to timbre parameters during playback are possible, allowing for performance expressions like delayed vibrato or filter sweeps.

Directly accepts NDJSON streams from external tools or live generation engines for real-time playback.

This simply enables the manipulation, playback, and exchange of structured musical data via UI or over a network within Tone.js.

# Design Philosophy
* This section was hastily generated by ChatGPT and may be rewritten in the future.

tonejs-json-sequencer adopts an approach where Tone.js components (synths, effect chains, parameter changes, etc.) are described directly in JSON.

It does not introduce its own music description language or abstraction layers; instead, such advanced logic is delegated to higher program layers.

Timbre definitions specify constructor names like `Tone.Synth` or `Tone.FMSynth`, along with their argument objects.

Event definitions also have a structure similar to Tone.js calls, such as `triggerAttackRelease`.

Parameter changes during playback are listed with function names, arguments, and event timestamps.

This achieves the goal of moving playback logic into data, making it externally configurable, without compromising Tone.js's audio expressive power.

The core `scheduleOrExecuteEvent` is a simple source file that accepts a single element, with higher layers handling sequencing and NDJSON streaming.

This allows for flexible, separate development of low-level layers connected to Tone.js and higher-level layers for sequencing and streaming.

# JSON Support for Tone.js Components

tonejs-json-sequencer enables major Tone.js components to be described in JSON.

## Overview of Support Status

### Currently Supported (‚úÖ)

- **Instrument**: Synth, MonoSynth, FMSynth, AMSynth, DuoSynth, MetalSynth, MembraneSynth, PluckSynth, NoiseSynth, PolySynth, Sampler
- **Effect**: Reverb, Freeverb, JCReverb, Chorus, Phaser, Tremolo, Vibrato, AutoFilter, AutoPanner, AutoWah, FeedbackDelay, PingPongDelay, Distortion, BitCrusher, Chebyshev, PitchShift, FrequencyShifter, StereoWidener

### Planned (üöß)

- **Source**: FatOscillator, PulseOscillator
- **Effect**: EQ3 (Equalizer), Compressor
- **Performance Methods**: Panpot changes, Expression changes, LPF (Low-Pass Filter) changes, Portamento

### Under Consideration (‚è≥)

- **Source**: Oscillator, OmniOscillator, Noise, Player, GrainPlayer, others
- **Effect**: Filter types, Dynamics types (Limiter, Gate), Spatial types (Convolver), others
- **Component**: Envelope types, LFO, Signal types, Analysis types (Meter, Analyser, FFT), others

## Detailed Documentation

For detailed support status, implementation priorities, and implementation policies for all components, please refer to the following document:

üìÑ [Tone.js Component JSON Support Roadmap (Detailed)](docs/tonejs-components-roadmap.ja.md)

This document includes the following information:
- Classification and implementation status of all components (Instrument / Source / Effect / Component)
- Implementation priorities and plans
- Implementation policy and approach
- Links to reference materials

# Roadmap
* Order is not fixed.
* Later, it would be good to split into two types: simple samples focusing on one topic for ease of use, and practical samples combining multiple topics to clearly demonstrate strengths.
- Program
  - NDJSON streaming, details to be described later.
- Structure
  - ‚úÖ Multi-timbral, FM Bass, and Saw Chord
- Performance Techniques
  - ‚úÖ Delayed Vibrato
  - Pitch envelope: -200 cents at attack, then changing to 0 cents (not attack-linked, but independent like delayed vibrato).
  - Sequence phrase changing Panpot from L to R on the fly.
  - Phrase increasing/decreasing Expression on the fly.
  - Phrase increasing/decreasing LPF on the fly.
- Effect
  - Reverb
  - Chorus
  - Delay
  - Phaser: apply a long sweep to a synth pad; if not possible, make it visible in the title etc.
  - EQ
  - Compressor
- Lead
  - ‚úÖ SuperSaw timbre (FatOscillator)
  - Distortion, preferably a guitar sound with Pluck.
  - Overdrive-like WaveShaper settings, preferably a guitar sound with Pluck.
  - Extreme synth lead using Chebyshev.
  - FM lead with long decay and harmonic changes; bright, typical FM lead; try pulse for modulator and carrier; if not possible, make it visible in the title etc.
  - Ambient lead: pulse timbre with subtle, randomly fluctuating pitch changes.
  - Unique lead: attack-linked pitch envelope with -200 cents at attack, then changing to 0 cents.
  - Lead with constant portamento.
- Sequence Timbres
  - PulseOscillator timbre with 12.5% pulse.
  - PluckSynth timbre for acoustic guitar or harp.
  - NoiseSynth with a filter to play a melodic phrase.
- Drum
  - Tone.js built-in Kick, Snare, Tom, Hi-Hat; if 909 Kick is not possible, make it visible in the title etc.
- Pad
  - ‚úÖ Thick synth pad with FatOscillator
  - FM Electric Piano
- Bass
  - Hard FM Bass
  - Synth bass with a constantly active attack-linked filter envelope.
  - Overdrive-like Saw synth bass with filter envelope, and filter changing with a long sweep.
- Other clear Tone.js audio samples will be added as found. For now, the above concludes this section.

# Development Notes, Regularly Updated
- Integration with tonejs-mml-to-json
  - Deferred. Will consider after organizing `tonejs-json-sequencer`'s verification data.
- NDJSON streaming
  - Goals:
    - Live editing: When a textarea is edited, changes are reflected while playback continues, rather than restarting.
    - Loop playback: When the end is reached, playback restarts from the beginning.
  - Method:
    - NDJSON streaming of events to be played within the next 50ms.
    - The time 50ms after the play button is pressed will be treated as 0 tick, and thereafter, event occurrence times in the sequencer will be processed by adding +50ms. This addition will also apply during loops.
    - Expected to be split into a separate HTML file with a separate source.
- `Tone.Transport.schedule` will not be used yet.
  - When I tried having an agent generate code, complex code was produced, but no improvement in the unnaturalness of the sound was observed.
  - I've determined it's premature; it's better to wait until test data is complete.
  - Future Outlook:
    - Implement the higher layer (tonejs-mml-to-json).
    - Create test data.
      - JSON that clearly shows rhythmic instability (drift).
        - e.g., high-tempo phrases with arpeggios, chords, and bass.
    - Perform the following:
      - Play that JSON with tonejs-json-sequencer and confirm the drift.
      - Implement `Tone.Transport.schedule` and test for drift improvement.
      - Implement and test the proven method successful with `postmate-midi`:
        - Process the time descriptions in the JSON in a higher layer to specify real-time, then play with NDJSON streaming.
        - Specify +50ms into the future as mentioned above.

# Challenges Under Consideration
- Challenge: Manually writing switch cases is tedious.
  - Policy: The approach is to write actual function calls within switch cases, as it's safe and simple; this is the current intention.
    - Concern: However, if switch cases grow large in the future, there's a concern that it might consume too much communication bandwidth for a lightweight library concept.
      - Assumption: Therefore, a mechanism to use only function names on a whitelist is an option, but it would increase complexity and the risk of security errors.
      - Deferred: This is a non-functional requirement, so it's better to consider it after dogfooding and confirming it's "too slow."
  - Analysis: Insufficient context for an agent to generate switch cases.
    - e.g., Unclear if `depth.rampTo` can be covered by generation.
    - e.g., It's unclear if `depth.rampTo` is sufficient as is, or what other method chains exist for other performance techniques or timbres; dogfooding is required.
    - Assumption: Even if full coverage could be generated, investigating during a test failure would be tedious (due to the large amount of source code).
  - Countermeasure: Continue with the current implementation policy and proceed with dogfooding.
- Consideration of a timbre library.
  * This might eventually be extracted as a separate project, similar to tonejs-mml-to-json.
  - Previous challenges:
    - It's unclear what the full potential of Tone.js is in terms of the sounds it can produce when mastered.
      - Here, "mastered" means within the scope of low-cost implementation, without external waveforms (soundfonts, etc.) or external AudioWorklets.
      - For example, for Saw and Square waves, the actual timbre characteristics, the presence or absence of aliasing noise in high frequencies, and their usefulness in FM connections are still unresearched and unknown.
        - For reference, I asked ChatGPT (caution: unverified), and it seems Tone.js generates a 1-loop waveform table when nodes are created, resulting in aliasing noise around the Nyquist frequency at high frequencies.
      - For example, FM:
        - Since it uses frequency modulation instead of phase modulation and lacks feedback,
        - it cannot produce phase-modulated or feedback-based timbres, but
        - the potential for what waveforms can be used for modulators and carriers and what timbres can be produced is still unresearched and unknown.
      - For example, SuperSaw:
        - How much additional refinement, such as effects, is needed
        - to create a practical, typical SuperSaw sound?
        - A clearer roadmap and workflow would be beneficial.
      - For example, even if one wanted to create a 64-sample, 8-bit waveform loop, Tone.js and Web Audio's architecture lacks a direct interface for this; probably the only method is to generate partials parameters via Fourier transform (if more is desired, external waveforms or AudioWorklets are the only option), but
        - whether this is actually the case is still unresearched and unknown.
      - For example, for Reverb / Chorus / Flanger / Phaser, it's still unknown due to insufficient research whether at least SC-88Pro level quality can be achieved.
      - For example, for Distortion types, including Overdrive, it's still unknown due to insufficient research whether at least SC-88Pro level quality can be achieved.
      - Since the use case is "compromise and use: educational, experimental," the inability to produce luxurious sounds is not particularly fatal.
        - What's important is to see "how much can be achieved? where is the sweet spot?" to enable smoother musical activities.
        - To add, Tone.js and Web Audio are positioned more towards simple signal processing rather than instruments. Understanding this, there's also the perspective of how much can be done instrument-like at low cost, with compromises.
        - Here, "low cost" implies "whether development can be done at low cost by standing on the shoulders of giants in the future, if a rich technical stack and ecosystem like tonejs-json-sequencer are cultivated."
        - Furthermore, Tone.js is recognized as superior in overall capability among the options.
        - In other words, when choosing the browser as a platform for free, open-source, multi-platform musical activities, Tone.js is recognized as superior in overall capability.
  - Countermeasures:
    - If timbre library sharing becomes easy,
      - the potential that can be realized with low-cost methods
      - will become easier to visualize.
  - Concept:
    - Share examples of "these timbres can be created, these effects can be applied, and combined, they can produce practical sounds of this level."
  - Benefits of a timbre library:
    - It is expected to form the foundation of the Tone.js ecosystem.
        - A previous challenge was the lack of reusability of individual user outputs.
        - If a foundation for sharing and linking individual user outputs can be established, their accumulation can allow future users to stand on the shoulders of giants.
          - This applies not only to timbres but to Web Audio in general.
  - Consideration of the timbre library's layer:
    - Not integrated into tonejs-json-sequencer,
    - but provided in a higher layer, a separate project.
  - How much to focus on the timbre library?
    - Under consideration.
    - If both the timbre library and timbre editor are well-developed, the ecosystem is likely to grow.
    - Developing minimum essential features for tonejs-json-sequencer has high priority.
      - Because the existence of functionality in tonejs-json-sequencer is a prerequisite for higher layers.
- Related to Why: Differentiating from DAWs.
  - DAWs
    - For prioritizing song completeness.
    - For maximizing composition/arrangement efficiency.
    - Quickly create high-quality songs! Ultimate practicality!
    - Required non-functional application requirements: low latency, no audio dropouts. Assumes use of high-performance machines.
  - tonejs-json-sequencer
    * Or, generally, non-DAW music applications on browsers, WebAudio, Tone.js, multi-platform.
    - For experimentation:
      - New UIs
      - New sounds, timbres, and songs using new methods.
    - New experiences:
      - e.g., educational music toys.
    - Interactive experiences:
      - e.g., educational music toys.
    - No non-functional requirements are demanded.
      - Fast implementation of features is desirable.
      - Multi-platform compatibility is desirable.

# Priorities
- Implement features with clear effects, e.g., delayed vibrato, multi-timbral.
- Safety. Security. Injection countermeasures. Do not use `eval` or similar.

# Out of Scope
- Node ID assignment ‚Üí Handled by higher layers, e.g., `tonejs-mml-to-json` or a JSON post-processor at a lower layer.
- Generating on/off for delayed vibrato for all notes ‚Üí Same as node ID assignment.
- Other data processing within JSON ‚Üí Same as node ID assignment.
- Exhaustiveness. Completely covering all combinations of Tone.js classes, methods, and method chains, and all patterns of function calls achievable with Tone.js via JSON.
- High performance. Choosing hard-to-maintain logic to minimize processing time and source file size.

# Automatic English Translation
README.md is automatically generated from README.ja.md using Gemini's translation via GitHub Actions.