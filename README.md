# tonejs-json-sequencer

[Japanese README](README.ja.md) / [English README](README.md)

[Demo](https://cat2151.github.io/tonejs-json-sequencer/src/index.html)

# Summary (3 Lines)

- A lightweight library that allows you to describe Tone.js instruments, effects, and performances using JSON.
- Control sounds with data, not code, enabling seamless integration with UIs and streaming.
-  Treats time-ordered events as data, allowing for precise musical expression.


# Why

- *Note: This section was initially generated by ChatGPT and may be revised in the future.*
- *In reality, most of the features are "planned for future implementation."*

Tone.js is a library that enables rich musical expression on the web.  It allows for sophisticated sound design in JavaScript, including synth construction, effect chains, and trigger scheduling.

However, this flexibility can lead to instrument sounds and patterns being deeply embedded in the program, making reuse and integration difficult.

`tonejs-json-sequencer` leverages Tone.js while externalizing instrument definitions, performance data, and timing information as JSON, enabling data-driven music playback.

Sequences are structured like SMF, explicitly listing all events in chronological order.

Instrument sounds can be flexibly defined in JSON using Tone.js's synth/chain/params.

Instrument parameters can be dynamically changed during playback, enabling expressive techniques like delay vibrato and filter sweeps.

It can directly receive NDJSON streams from external tools or live generation engines for real-time playback.

This simplifies the process of manipulating, playing, and exchanging structured musical data over UIs and networks within Tone.js.

# Design Philosophy

- *Note: This section was initially generated by ChatGPT and may be revised in the future.*

`tonejs-json-sequencer` uses a straightforward approach:  directly describing Tone.js components (synths, effect chains, parameter changes) in JSON.

It avoids introducing a custom musical notation language or abstraction layer; complex logic is left to higher-level program layers.

Instrument definitions specify the constructor names (e.g., `Tone.Synth`, `Tone.FMSynth`) and their argument objects.

Event definitions mirror the structure of Tone.js calls like `triggerAttackRelease`.

Runtime parameter changes list function names and arguments along with event timestamps.

This achieves the goal of making the playback logic data-driven and externally configurable without sacrificing Tone.js's expressive capabilities.

The core `scheduleOrExecuteEvent` function is a simple source file accepting a single element, allowing higher layers to handle sequencing and NDJSON streaming.  This cleanly separates the low-level Tone.js integration from higher-level sequencing and streaming concerns.

# Roadmap

- *Items are not in order.*
- *Later, we will divide this into two types: a simple sample focusing on ease of use with one topic and a practical sample combining multiple topics to showcase its strengths.*
- **Programming:**
  - NDJSON streaming (details below)
- **Structure:**
  - Completed: Multi-timbral, FM Bass, and Saw Chord
- **Playing Techniques:**
  - Completed: Delay vibrato
  - Pitch envelope: -200 cents on attack, then changing to 0 cents (independent of attack, similar to delay vibrato)
  - Sequence phrase changing panpot to L/R on the fly
  - Phrase dynamically increasing/decreasing expression
  - Phrase dynamically increasing/decreasing LPF
- **Effects:**
  - Reverb
  - Chorus
  - Delay
  - Phaser (long sweep for synth pad; indicate limitations in the title if necessary)
  - EQ
  - Compressor
- **Leads:**
  - SuperSaw sound (FatOscillator)
  - Distortion (pluck guitar if possible)
  - Overdrive-style WaveShaper (pluck guitar if possible)
  - Aggressive synth lead using Chebyshev
  - FM lead with long decay and changing overtones (bright, typical FM lead using pulse for both modulator and carrier; indicate limitations in the title if necessary)
  - Ambient lead (pulse sound, subtly fluctuating pitch)
  - Unique lead (attack-linked pitch envelope: -200 cents on attack, then changing to 0 cents)
  - Lead with constant portamento
- **Sequence Instruments:**
  - PulseOscillator sound (12.5% pulse)
  - PluckSynth sound (acoustic guitar or harp)
  - NoiseSynth with filter for melodic phrases
- **Drums:**
  - Tone.js built-in Kick, Snare, Tom, Hi-Hat (909 Kick if possible; otherwise, indicate limitations in the title)
- **Pads:**
  - Thick synth pad using FatOscillator
  - FM electric piano
- **Basses:**
  - Hard FM bass
  - Synth bass with constant attack-linked filter envelope
  - Overdrive-style Saw synth bass with filter envelope and long filter sweep
- We will add more samples using Tone.js sounds as soon as we find suitable ones.  For now, the above is a good starting point.

# Development Notes (Constantly Updated)

- Integration with `tonejs-mml-to-json`
  - Postponed.  We will consider this after organizing the verification data for `tonejs-json-sequencer`.
- NDJSON streaming
  - Goal:
    - Live editing:  When the textarea is edited, instead of replaying, the changes are reflected while playback continues.
    - Loop playback: Playback starts from the beginning after reaching the end.
  - Method:
    - NDJSON stream events to be played within the next 50 milliseconds.
    - Treat 50 milliseconds after the play button is pressed as 0 ticks, and add 50 milliseconds to event times in the sequencer section.  Further addition occurs during loops.
    - We plan to separate this into a different src in a separate HTML file.

# Issues Under Consideration

- **Problem:** Manually writing `switch`-`case` statements is tedious.
  - **Approach:** We will primarily use `switch`-`case` statements for actual function calls, as this is safe and simple.
    - **Concern:** However, if the `switch`-`case` statements become large, communication speed may become a concern, contradicting the lightweight library concept.
      - **Solution:**  Consider a mechanism that only uses functions on a whitelist.  However, this increases complexity and the risk of security errors.
        - **Postponed:** This is a non-functional requirement, so it's better to address it after dogfooding and encountering performance issues.
  - **Analysis:** Generating `switch`-`case` statements with an agent lacks sufficient context.
    - **Example:** It is unclear whether `depth.rampTo` can be comprehensively handled by code generation.
    - **Example:** It's unknown whether `depth.rampTo` is currently suitable, or what method chains exist for other playing techniques or sounds – dogfooding is needed.
    - **Solution:** Even if code generation could comprehensively handle everything, testing would be laborious (due to the large source code).
  - **Countermeasure:** Maintain the current implementation approach and proceed with dogfooding.

# Priorities

- Implement features with clear effects, such as delay vibrato and multi-timbrality.
- Ensure safety and security. Prevent injection attacks. Avoid using `eval` or similar functions.

# Out of Scope

- `nodeId` assignment → This will be handled by the upper layer, such as `tonejs-mml-to-json` or a lower-level JSON post-processor.
- Generating `on` and `off` for delay vibrato for all notes → Similar to `nodeId` assignment.
- Other JSON data processing → Similar to `nodeId` assignment.
- Exhaustive coverage:  Completely covering all Tone.js classes, methods, and method chain combinations to fully support all possible function calls in JSON.
- High performance:  Avoiding hard-to-maintain logic to minimize processing time and source file size.


# Automatic Translation

`README.md` is automatically generated using GitHub Actions with a Gemini translation of `README.ja.md`.
