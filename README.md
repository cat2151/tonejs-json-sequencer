# tonejs-json-sequencer

<p align="left">
  <a href="https://deepwiki.com/cat2151/tonejs-json-sequencer"><img src="https://img.shields.io/badge/DeepWiki-Documentation-blue?logo=book" alt="DeepWiki"></a>
  <a href="README.ja.md"><img src="https://img.shields.io/badge/üáØüáµ-Japanese-red.svg" alt="Japanese"></a>
  <a href="README.md"><img src="https://img.shields.io/badge/üá∫üá∏-English-blue.svg" alt="English"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/index.html"><img src="https://img.shields.io/badge/üöÄ-Live%20Demo-brightgreen.svg" alt="Demo"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/streaming.html"><img src="https://img.shields.io/badge/üéµ-Streaming%20Demo-orange.svg" alt="Streaming Demo"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/demo-library/"><img src="https://img.shields.io/badge/üì¶-Library%20Demo-blue.svg" alt="Library Demo"></a>
</p>

# Status
- Frequent breaking changes are planned.
- This document and related content may contain AI-generated text; plans and concepts might be inaccurate or differ from cat2151's original vision.

# Key Features in 3 Lines
- A lightweight library that allows describing Tone.js timbres, effects, and performances using JSON.
- Control sound with data instead of writing code, enabling seamless integration with UI and streaming.
- Handle time-ordered events as data, allowing for intricate performance expressions.

# Why
- *This section was temporarily generated by ChatGPT and may be rewritten in the future.*
- *In reality, a large portion is "planned for future implementation."*

Tone.js is a library that enables rich musical expression on the web. It allows for advanced audio design using JavaScript, including building synths, effect chains, and scheduling triggers.

However, due to its flexibility, the structure of sounds and patterns can often become deeply embedded in the program, making reuse and integration difficult.

`tonejs-json-sequencer` is a small mechanism that leverages Tone.js while externalizing timbre definitions, performance content, and timing information as JSON, enabling data-driven music playback.

Sequences are structured like SMF (Standard MIDI File), where "all events are explicitly arranged in chronological order."

Timbres can be flexibly defined in JSON using Tone.js's `synth`/`chain`/`params`.

Dynamic modification of timbre parameters during playback allows for expressive playing techniques such as delayed vibrato or filter sweeps.

It can directly receive NDJSON streams from external tools or live generation engines for real-time playback.

This simplifies the process of manipulating, playing, and exchanging structured musical data via UI or network on Tone.js.

# Design Philosophy
- *This section was temporarily generated by ChatGPT and may be rewritten in the future.*

`tonejs-json-sequencer` takes the approach of describing Tone.js components (synths, effect chains, parameter changes, etc.) directly in JSON.

Instead of introducing a unique music description language or abstraction layer, the design delegates such high-level logic to higher program layers.

Timbre definitions specify the constructor name (e.g., `Tone.Synth`, `Tone.FMSynth`) and argument object.

Event definitions are structured similarly to Tone.js method calls (e.g., `triggerAttackRelease`).

Parameter changes during playback are listed as function names and arguments, along with the event's timestamp.

This approach achieves the goal of moving playback logic into data, making it configurable externally, without compromising Tone.js's sonic expressive power.

The core `scheduleOrExecuteEvent` is a simple source file that accepts a single element, with sequence and NDJSON streaming handled in higher layers.

This separation allows for flexible development of the low-level connection to Tone.js and high-level features like sequencing and streaming.

# Using as a library

`tonejs-json-sequencer` can be used as a library in other projects.

## Installation

### Using npm

```bash
npm install tonejs-json-sequencer tone
```

### Installing directly from GitHub

You can install directly from GitHub to use the latest development version:

```bash
npm install cat2151/tonejs-json-sequencer tone
```

For a complete example of using the library from an external project via GitHub installation, refer to the [demo-library](https://cat2151.github.io/tonejs-json-sequencer/demo-library/) directory.

### Referencing `dist/` directory directly

You can clone or download this repository and refer to the files directly within the `dist/` directory.

#### ES Modules (Recommended)

```javascript
import { SequencerNodes, playSequence } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

#### CommonJS

```javascript
const { SequencerNodes, playSequence } = require('./path/to/tonejs-json-sequencer/dist/cjs/index.js');
```

#### TypeScript

When using TypeScript, type definition files are also included in the `dist/` directory:

```typescript
import { SequencerNodes, playSequence, SequenceEvent } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

Type definition file: `dist/index.d.ts`

### Using CDN

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

Or using unpkg:

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://unpkg.com/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

## Basic Usage Example

```typescript
import * as Tone from 'tone';
import { SequencerNodes, playSequence } from 'tonejs-json-sequencer';

// Define the sequence in JSON
const sequence = [
  {
    eventType: 'createNode',
    nodeId: 0,
    nodeType: 'Synth',
    args: { oscillator: { type: 'sine' } }
  },
  {
    eventType: 'connect',
    nodeId: 0,
    connectTo: 'toDestination'
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['C4', '8n', '0']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['E4', '8n', '0:0:2']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['G4', '8n', '0:1:0']
  }
];

// Create a node manager
const nodes = new SequencerNodes();

// Play the sequence
async function play() {
  await Tone.start();
  await playSequence(Tone, nodes, sequence);
}

// Bind to button click
document.getElementById('playButton').addEventListener('click', play);
```

## Browser Usage Example (with CDN)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Tonejs JSON Sequencer Example</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@15.0.4/build/Tone.js"></script>
</head>
<body>
  <button id="playButton">Play</button>
  
  <script type="module">
    import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';

    const sequence = [
      {
        eventType: 'createNode',
        nodeId: 0,
        nodeType: 'Synth',
        args: { oscillator: { type: 'sine' } }
      },
      {
        eventType: 'connect',
        nodeId: 0,
        connectTo: 'toDestination'
      },
      {
        eventType: 'triggerAttackRelease',
        nodeId: 0,
        args: ['C4', '4n', '0']
      }
    ];

    const nodes = new SequencerNodes();

    document.getElementById('playButton').addEventListener('click', async () => {
      await Tone.start();
      await playSequence(Tone, nodes, sequence);
    });
  </script>
</body>
</html>
```

## `dist/` Directory Structure

The `dist/` directory contains the following files:

- `index.mjs` - Entry point in ES Modules format
- `index.js` - Entry point in CommonJS format
- `index.d.ts` - TypeScript type definition file
- `esm/` - Compiled files in ES Modules format
- `cjs/` - Compiled files in CommonJS format

You can choose the appropriate file format based on your project requirements.

## Samples

For more detailed usage examples, refer to the `examples/` directory:

- `examples/cdn-example.html` - Browser usage example with CDN
- `examples/npm-example.mjs` - Usage example as an npm package

## NDJSON Streaming

`tonejs-json-sequencer` supports NDJSON (Newline Delimited JSON) streaming, enabling real-time playback, live editing, and loop playback.

### Features

-   **Live Editing**: Edit sequences during playback ‚Äì changes are reflected in real-time without restarting.
-   **Loop Playback**: Automatically loops when the sequence ends.
-   **50ms Lookahead**: Events are scheduled 50ms in advance for smooth and accurate playback.

### Basic Usage

```typescript
import * as Tone from 'tone';
import { SequencerNodes, NDJSONStreamingPlayer } from 'tonejs-json-sequencer';

// Create a node manager
const nodes = new SequencerNodes();

// Create a streaming player with settings
const player = new NDJSONStreamingPlayer(Tone, nodes, {
  lookaheadMs: 50,    // Lookahead time (milliseconds)
  loop: true,         // Enable loop playback
  onLoopComplete: () => {
    console.log('Loop complete!');
  }
});

// Start playback with an NDJSON string or event array
const ndjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["C4","8n","0"]}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["E4","8n","0:0:2"]}
`;

await Tone.start();
await player.start(ndjson);

// Update sequence during playback (live editing)
const updatedNdjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["G4","8n","0"]}
`;
await player.start(updatedNdjson);  // Update without stopping

// Stop playback
player.stop();
```

### Demo

For a full interactive demo of live editing and loop playback, refer to `streaming.html`.

# JSON Support for Tone.js Components

`tonejs-json-sequencer` enables describing key Tone.js components using JSON.

## Compatibility Overview

### Currently Supported (‚úÖ)

-   **Instrument**: Synth, MonoSynth, FMSynth, AMSynth, DuoSynth, MetalSynth, MembraneSynth, PluckSynth, NoiseSynth, PolySynth, Sampler
-   **Effect**: Reverb, Freeverb, JCReverb, Chorus, Phaser, Tremolo, Vibrato, AutoFilter, AutoPanner, AutoWah, FeedbackDelay, PingPongDelay, Distortion, BitCrusher, Chebyshev, PitchShift, FrequencyShifter, StereoWidener

### Planned (üöß)

-   **Source**: FatOscillator, PulseOscillator
-   **Effect**: EQ3 (Equalizer), Compressor
-   **Performance Methods**: Panpot change, Expression change, LPF change, Portamento

### Under Consideration (‚è≥)

-   **Source**: Oscillator, OmniOscillator, Noise, Player, GrainPlayer, etc.
-   **Effect**: Filter types, Dynamics types (Limiter, Gate), Spatial types (Convolver), etc.
-   **Component**: Envelope types, LFO, Signal types, Analysis types (Meter, Analyser, FFT), etc.

## Detailed Documentation

For a detailed compatibility status of all components, implementation priority, and policy, please refer to the following document:

üìÑ [Tone.js Components JSON Support Roadmap (Detailed)](docs/tonejs-components-roadmap.ja.md)

This document includes the following information:
- Classification and implementation status of all components (Instrument / Source / Effect / Component)
- Implementation priority and plan
- Implementation policy and approach
- Links to reference materials

# Roadmap for Unimplemented JSON Events

This section lists features that are "possible with Tone.js but not yet implemented as JSON events."

## Currently Implemented JSON Events

-   `createNode` - Creates synth and effect nodes.
-   `connect` - Connects nodes.
-   `triggerAttackRelease` - Triggers note playback.
-   `depth.rampTo` - Smoothly changes the `depth` parameter.
-   `volume.rampTo` - Smoothly changes the `volume` parameter.
-   `rampTo` - Generic parameter ramp (dot-separated string/array path specification). Arguments are `[value, targetPath]` or `[value, rampTime, targetPath, time?]`.
-   `LFO` - Creates an LFO for the specified parameter path and starts modulation (start time is optional, specified in Tone.Transport time).
-   `set` - Global settings (currently only `Transport.bpm.value` is supported).
-   `loopEnd` - Marks an explicit loop boundary for streaming playback (metadata event).

### LFO Event Example

```json
{
  "eventType": "LFO",
  "nodeId": 1,
  "args": [
    { "frequency": "4n", "min": 0, "max": 10, "type": "sine" },
    "filter.Q",
    "0:0:0"
  ]
}
```

### rampTo Event Example

```json
{
  "eventType": "rampTo",
  "nodeId": 1,
  "args": [0.75, "4n", "filter.Q", "0:0:0"]
}
```

## List of Unimplemented Features

### High Priority: JSON Events Required for Expressive Performance

These are crucial features that directly impact performance expression.

#### Panpot Control ‚è≥
-   **Overview**: Changes stereo position (L/R) in real-time.
-   **Required JSON Events**:
    -   `pan.rampTo` - Smooth pan changes.
    -   `pan.value` - Immediate pan changes.
-   **Tone.js Implementation**: Controlled via Param API on corresponding nodes with a `.pan` parameter (e.g., `PanVol` / `Panner`).
-   **Example Use**: Dynamically changing L/R in a sequence phrase.

#### LPF Cutoff Frequency and Resonance Control ‚è≥
-   **Overview**: Changes low-pass filter cutoff frequency and Q value in real-time.
-   **Required JSON Events**:
    -   `filter.frequency.rampTo` - Smooth cutoff frequency changes.
    -   `filter.Q.rampTo` - Smooth resonance (Q value) changes.
    -   `filter.frequency.value` - Immediate cutoff frequency changes.
    -   `filter.Q.value` - Immediate resonance (Q value) changes.
-   **Tone.js Implementation**: Supported by synths with filters like MonoSynth.
-   **Example Use**: Filter sweeps in phrases, long sweeps, attack-linked filter envelopes.

#### Pitch Control (Portamento/Pitch Envelope) ‚è≥
-   **Overview**: Smoothly changes pitch.
-   **Required JSON Events**:
    -   `frequency.rampTo` - Smooth frequency changes (portamento).
    -   `detune.rampTo` - Smooth detune changes (pitch envelope).
-   **Tone.js Implementation**: `frequency`/`detune` parameters of oscillators and synths.
-   **Example Use**: Portamento, pitch envelope during attack (e.g., -200 cents to 0 cents).

#### Expression Control ‚è≥
-   **Overview**: Dynamically controls volume and other parameters.
-   **Required JSON Events**:
    -   (Short-term) Add individual events for key parameters like volume.
    -   (Mid-to-long-term) General parameter access mechanism.
    -   Example: `<nodeId>.<paramPath>.rampTo` format (assuming `paramPath` itself is whitelisted and supported paths are enumerated).
-   **Design Policy / Roadmap**:
    -   Continue using a **node ID whitelist via switch-case**.
    -   If `<nodeId>.<paramPath>.rampTo` is introduced, `paramPath` must not be an arbitrary string but **only pre-defined paths**.
    -   First, increase individual events, identify necessary patterns, and then consider a generic mechanism with enumerated supported paths.
-   **Tone.js Implementation**: All Param objects support `rampTo`.
-   **Example Use**: Increase/decrease expression in a phrase, dynamic changes.

### Medium Priority: Effect Parameter Control

#### Reverb Parameters ‚è≥
-   **Required JSON Events**: `decay.rampTo`, `wet.rampTo`, etc.
-   **Use Case**: Dynamically change reverb depth or room size.

#### Chorus Parameters ‚è≥
-   **Required JSON Events**: `frequency.rampTo`, `depth.rampTo` (Chorus specific).
-   **Use Case**: Dynamically change chorus speed or depth.

#### Delay Parameters ‚è≥
-   **Required JSON Events**: `delayTime.rampTo`, `feedback.rampTo`, etc.
-   **Use Case**: Dynamically change delay time or feedback amount.

#### Phaser Parameters ‚è≥
-   **Required JSON Events**: `frequency.rampTo`, `octaves.rampTo`, `Q.rampTo`, etc.
-   **Use Case**: Long phaser sweeps, modulation for pads.

#### EQ (Equalizer) Parameters ‚è≥
-   **Required JSON Events**: `low.rampTo`, `mid.rampTo`, `high.rampTo`, etc.
-   **Use Case**: Adjust levels for specific frequency bands.

#### Compressor Parameters ‚è≥
-   **Required JSON Events**: `threshold.rampTo`, `ratio.rampTo`, `attack.rampTo`, `release.rampTo`, etc.
-   **Use Case**: Dynamic adjustment of dynamics processing.

### Low Priority: Advanced Features

#### Envelope Control ‚è≥
-   **Required JSON Events**: Access to ADSR parameters.
-   **Use Case**: Dynamic changes to envelope shape.

#### LFO Parameters ‚è≥
-   **Required JSON Events**: Control of LFO frequency, depth, and waveform.
-   **Use Case**: Dynamic changes to modulation.

#### 3D Panning ‚è≥
-   **Required JSON Events**: 3D spatial positioning control.
-   **Use Case**: Achieving spatial audio.

## Check for Implemented Features

### Tempo (BPM) Control ‚úÖ
-   **Implementation Status**: ‚úÖ **Implemented**
-   **JSON Event**: `set` event with `nodeType: 'Transport.bpm.value'`
-   **Usage Example**:
    ```json
    {
      "eventType": "set",
      "nodeId": 0,
      "nodeType": "Transport.bpm.value",
      "args": [120]
    }
    ```

### Delayed Vibrato ‚úÖ
-   **Implementation Status**: ‚úÖ **Implemented**
-   **Implementation Method**: Uses `depth.rampTo`.

## Implementation Policy

1.  **Prioritize Security**: Continue using a whitelist approach with `switch-case`, without using `eval` or similar functions.
2.  **Incremental Implementation**: Implement high-priority features sequentially.
3.  **Dogfooding**: Validate implemented features through actual use.

## References

-   Detailed component compatibility status: [Tone.js Components JSON Support Roadmap](docs/tonejs-components-roadmap.ja.md)
-   Tone.js official documentation: https://tonejs.github.io/docs/

# Roadmap
- *Order is not fixed.*
- *Will later be split into two types: a simple sample focused on one topic for ease of use, and a practical sample combining multiple topics to highlight strengths.*
- Program
  - Done: NDJSON streaming with live editing and loop playback (see streaming.html)
- Structure
  - Done: Multitimbral, FM Bass, and Saw Chord
- Performance Techniques
  - Done: Delayed vibrato
  - Pitch envelope: attack at -200 cents, then changes to 0 cents (independent of attack, like delayed vibrato)
  - Sequence phrase with immediate L/R Panpot changes
  - Phrase with immediate expression increases/decreases
  - Phrase with immediate LPF increases/decreases
- Effect
  - Reverb
  - Chorus
  - Delay
  - Phaser: apply a long sweep to a synth pad; if not possible, state it clearly in the title or elsewhere
  - EQ
  - Compressor
- Lead
  - Done: SuperSaw timbre (FatOscillator)
  - Distortion, preferably with Pluck for guitar
  - Overdrive-like WaveShaper settings, preferably with Pluck for guitar
  - Extreme synth lead using Chebyshev
  - Long decay FM lead with harmonic changes, typical shimmering FM lead, try pulse for modulator and carrier; if not possible, state it clearly in the title or elsewhere
  - Ambient lead, pulse timbre, slightly random wavering pitch changes
  - Quirky lead: attack-linked pitch envelope with attack at -200 cents, then changing to 0 cents
  - Lead with constant portamento
- Sequence Timbres
  - PulseOscillator timbre with 12.5% pulse
  - PluckSynth timbre for acoustic guitar or harp
  - NoiseSynth with a filter to play pitched phrases
- Drum
  - Tone.js built-in Kick, Snare, Tom, Hi-Hat; if 909 Kick is not possible, state it clearly in the title or elsewhere
- Pad
  - Done: Thick synth pad with FatOscillator
  - FM Electric Piano
- Bass
  - Hard FM bass
  - Synth bass with a constant attack-linked filter envelope
  - Overdrive-like Saw synth bass with a filter envelope, and a long filter sweep
- Add other notable Tone.js samples that clearly demonstrate sound. For now, the above list is a good starting point.

# Development Notes, Updated Periodically
- Integration with tonejs-mml-to-json
  - Postpone. Will consider after organizing the verification data for tonejs-json-sequencer.
- NDJSON streaming
  - Status: ‚úÖ **Implementation Complete** (See `streaming.html` and `src/ndjson-streaming.ts`)
  - Implemented features:
    - Live editing: When editing the textarea, playback continues, and changes are reflected without replaying from scratch.
    - Loop playback: Plays from the beginning when the end is reached.
    - 50ms lookahead: Events are scheduled 50ms in advance for smooth playback.
  - Implementation details:
    - `NDJSONStreamingPlayer` class processes events at lookahead timing.
    - Continuous event processing using `requestAnimationFrame`.
    - `parseNDJSON` function supports both arrays and NDJSON strings.
    - `streaming.html` has an independent demo and dedicated source files.
- Tone.Transport.schedule is not yet used.
  - When I had the agent generate code for it, the resulting code was complex, and I couldn't confirm any improvement in sound articulation.
  - I've decided it's premature and better to wait until test data is ready.
  - Future outlook:
    - Implement a higher layer (tonejs-mml-to-json).
    - Create test data:
      - JSON that clearly shows rhythmic instability (e.g., fast arpeggios, chords, bass phrases).
    - Perform the following:
      - Play the JSON with tonejs-json-sequencer and confirm the instability.
      - Implement `Tone.Transport.schedule` and test for instability improvement.
      - Implement and test the successful method used in postmate-midi:
        - Process the time description in the JSON at a higher layer to specify real-time, then play with NDJSON streaming.
        - As mentioned, specify +50ms in the future.

# Issues Under Consideration
- Challenge: Manually writing switch cases is tedious.
  - Policy: Writing actual function calls with switch-case is safe and simple, so I plan to stick with this approach.
    - Concern: However, if the switch-case becomes too large in the future, there's a risk of high communication speed, which contradicts the lightweight library concept.
      - Assumption: Therefore, I'll keep the option of using only whitelisted function names, but this increases complexity and the risk of security errors.
        - Postpone: This is a non-functional requirement, so it's better to consider it after "too slow" is identified through dogfooding.
  - Analysis: Insufficient context for the agent to generate switch cases.
    - Example: Unsure if `depth.rampTo` and similar commands can be comprehensively generated.
    - Example: Is the current `depth.rampTo` sufficient? What other method chains for performance techniques and timbres exist? This requires dogfooding.
    - Assumption: Even if all coverage could be generated, investigating during `test red` would be time-consuming (due to the vast codebase).
  - Countermeasure: Stick to the current implementation policy and proceed with dogfooding.
- Consideration of a timbre library
  - *This might eventually be separated into a distinct project, similar to tonejs-mml-to-json.*
  - Past challenges:
    - It's unclear how much sound potential Tone.js has when mastered.
      - "Mastered" here means within the scope of low-cost implementation, without external waveforms (soundfonts, etc.) or external AudioWorklets.
      - For example, for Saw and Square waves, the actual sonic character, presence/absence of aliasing noise at high frequencies, and utility for FM connections are unexplored.
        - (Note: Based on a query to ChatGPT, which should be verified), Tone.js generates a single loop of the waveform table during node creation, and aliasing noise is expected around the Nyquist frequency at high frequencies.
      - For example, for FM:
        - It uses frequency modulation, not phase modulation, and lacks feedback, so phase modulation and feedback-based timbres cannot be produced.
        - However, the potential of what timbres can be created using various waveforms for modulator and carrier is unexplored.
      - For example, for SuperSaw:
        - How much additional crafting (e.g., effects) is needed to achieve a practical, typical SuperSaw sound?
        - A clearer roadmap and workflow would be beneficial.
      - For example, to create a 1-loop, 64-sample, 8-bit waveform, Tone.js or Web Audio mechanisms don't seem to offer a direct interface. The only way might be to generate `partials` parameters via Fourier transform (anything more would require external waveforms or AudioWorklets).
        - However, whether this is actually the case is unexplored.
      - For example, for Reverb / Chorus / Flanger / Phaser, can a minimum level comparable to SC-88Pro be achieved? This is insufficiently explored.
      - For example, for Distortion types, including Overdrive types, can a minimum level comparable to SC-88Pro be achieved? This is insufficiently explored.
      - The purpose is "to use with compromise: for educational and experimental purposes," so the inability to produce luxurious sounds is not critical.
        - What's important is visualizing "how far can it go? Where is the sweet spot?" to facilitate smoother musical activities.
        - To clarify, Tone.js and Web Audio are positioned more towards simple signal processing than musical instruments. Understanding this, the question is, how much can be achieved instrumentally at low cost with compromises?
        - "Low cost" here refers to whether development can become low-cost by standing on the shoulders of giants if the technology stack and ecosystem (like tonejs-json-sequencer) mature.
        - Tone.js is generally recognized as superior in overall capability.
        - That is, when choosing the browser as a platform for free, open-source, cross-platform music activities, Tone.js is recognized as having superior overall capability.
  - Countermeasure:
    - If timbre library sharing becomes easy,
      - The potential that can be achieved with low-cost methods will become more visible.
  - Image:
    - Share examples like "these timbres can be created," "these effects can be applied," and "combining them yields this level of practical sound."
  - Benefits of a timbre library:
    - Expected to foster the Tone.js ecosystem.
        - A past challenge has been the lack of reusability of users' individual outputs.
        - If an ecosystem for sharing and collaborating on users' outputs can be established and accumulated, future users can stand on the shoulders of giants.
          - This applies not only to timbres but to Web Audio in general.
  - Consideration of the timbre library's layer:
    - Not to be integrated into `tonejs-json-sequencer`,
    - but to be provided at a higher layer, in a separate project.
  - How much to focus on the timbre library?
    - Under consideration.
    - A rich timbre library and editor would likely help the ecosystem grow.
    - High priority to implement minimum functionality in `tonejs-json-sequencer` as it's a prerequisite for higher layers.
- Why related: Distinction from DAWs
  - DAWs:
    - For prioritizing song completeness.
    - For maximizing composition and arrangement efficiency.
    - Quick creation of high-quality songs! Maximum practicality!
    - Required non-functional requirements: low latency, no audio dropouts. Assumes use of high-performance machines.
  - tonejs-json-sequencer:
    - *Or generally, non-DAW-like music apps across browsers, WebAudio, Tone.js, and multiple platforms.*
    - For experimentation:
      - New UIs.
      - New sounds, timbres, and songs using new methods.
    - New experiences:
      - Inspiration for composition.
    - Interactive experiences:
      - E.g., educational music toys.
    - Required non-functional requirements: none.
      - Quick realization of functionality is good.
      - Cross-platform is good.

# Priorities
- Implement features with clear impact, such as delayed vibrato and multitimbrality.
- Safety and security. Injection prevention. Avoid `eval` and similar functions.

# Out of Scope
-   `nodeId` numbering: This will be handled by a higher layer, e.g., `tonejs-mml-to-json` or a lower-level JSON post-processor.
-   Generating `on` and `off` for delayed vibrato for all notes: Similar to `nodeId` numbering.
-   Other data processing within JSON: Similar to `nodeId` numbering.
-   Comprehensiveness: To completely cover all classes, methods, and method chain combinations of Tone.js, and fully encompass all patterns of function calls achievable via JSON.
-   High performance: Choosing less maintainable logic to minimize processing time or source file size.

# Automatic English Translation
`README.md` is automatically generated from `README.ja.md` using Gemini's translation via GitHub Actions.