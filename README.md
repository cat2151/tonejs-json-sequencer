# tonejs-json-sequencer

<p align="left">
  <a href="https://deepwiki.com/cat2151/tonejs-json-sequencer"><img src="https://img.shields.io/badge/DeepWiki-Documentation-blue?logo=book" alt="DeepWiki"></a>
  <a href="README.ja.md"><img src="https://img.shields.io/badge/üáØüáµ-Japanese-red.svg" alt="Japanese"></a>
  <a href="README.md"><img src="https://img.shields.io/badge/üá∫üá∏-English-blue.svg" alt="English"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/index.html"><img src="https://img.shields.io/badge/üöÄ-Live%20Demo-brightgreen.svg" alt="Demo"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/streaming.html"><img src="https://img.shields.io/badge/üéµ-Streaming%20Demo-orange.svg" alt="Streaming Demo"></a>
</p>

# Status
- Frequent breaking changes are planned.
- This document and related documentation include AI-generated content, and plans may be incorrect (different from cat2151's vision).

# Explained in 3 lines
- A lightweight library that allows describing Tone.js timbres, effects, and performances using JSON.
- Control sound with data without writing code, enabling seamless integration with UI and streaming.
- Handle time-ordered events as data, allowing for intricate performance expressions.

# Why
- *(Generated by ChatGPT as a stopgap measure. May be rewritten in the future.)*
- *(Note: A large part of this is "planned for future implementation".)*

Tone.js is a library that enables rich musical expression on the web. It allows for advanced sound design in JavaScript, such as building synths, effect chains, and scheduling triggers.

However, due to its flexibility, the structure of timbres and patterns can easily become deeply embedded in the program, making reuse and integration difficult.

`tonejs-json-sequencer` is a small mechanism that leverages Tone.js while externalizing timbre definitions, performance content, and timing information as JSON, enabling data-driven music playback.

A sequence is structured like an SMF, explicitly listing all events in chronological order.

Timbres can be flexibly defined in JSON using Tone.js's synth/chain/params.

Dynamic changes to timbre parameters are possible even during playback, allowing for expressive techniques like delay vibrato or filter sweeps.

It can directly receive NDJSON streams from external tools or live generation engines for real-time playback.

This simplifies the process of manipulating, playing, and exchanging structured musical data via UI or network using Tone.js.

# Design Philosophy
- *(Generated by ChatGPT as a stopgap measure. May be rewritten in the future.)*

`tonejs-json-sequencer` takes an approach where Tone.js components (synths, effect chains, parameter changes, etc.) are described directly in JSON.

It does not introduce its own music description language or abstraction layer, instead delegating such advanced logic to higher program layers.

Timbre definitions specify constructor names like `Tone.Synth` or `Tone.FMSynth` and their argument objects.

Event definitions also have a structure similar to Tone.js calls, such as `triggerAttackRelease`.

Parameter changes during performance are listed with function names, arguments, and event timestamps.

This achieves the goal of shifting playback logic to data and making it configurable externally, without compromising the sonic expressive power of Tone.js.

The core `scheduleOrExecuteEvent` is a simple source file that only receives a single element, while higher layers handle sequences and NDJSON streaming.

This allows for flexible development by separating the low layer connected to Tone.js from high layers like sequencing and streaming.

# Usage as a Library

`tonejs-json-sequencer` can be used as a library in other projects.

## Installation

### Using npm

```bash
npm install tonejs-json-sequencer tone
```

### Directly referencing the `dist/` directory

You can clone or download this repository and directly reference the files in the `dist/` directory.

#### ES Modules (Recommended)

```javascript
import { SequencerNodes, playSequence } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

#### CommonJS

```javascript
const { SequencerNodes, playSequence } = require('./path/to/tonejs-json-sequencer/dist/cjs/index.js');
```

#### TypeScript

If you are using TypeScript, type definition files are also included in the `dist/` directory:

```typescript
import { SequencerNodes, playSequence, SequenceEvent } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

Type definition file: `dist/index.d.ts`

### Using CDN

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

Or using unpkg:

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://unpkg.com/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

## Basic Usage Example

```typescript
import * as Tone from 'tone';
import { SequencerNodes, playSequence } from 'tonejs-json-sequencer';

// Define the sequence in JSON
const sequence = [
  {
    eventType: 'createNode',
    nodeId: 0,
    nodeType: 'Synth',
    args: { oscillator: { type: 'sine' } }
  },
  {
    eventType: 'connect',
    nodeId: 0,
    connectTo: 'toDestination'
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['C4', '8n', '0']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['E4', '8n', '0:0:2']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['G4', '8n', '0:1:0']
  }
];

// Create a node manager
const nodes = new SequencerNodes();

// Play the sequence
async function play() {
  await Tone.start();
  await playSequence(Tone, nodes, sequence);
}

// Bind to a button click
document.getElementById('playButton').addEventListener('click', play);
```

## Browser Usage Example (using CDN)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Tonejs JSON Sequencer Example</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@15.0.4/build/Tone.js"></script>
</head>
<body>
  <button id="playButton">Play</button>
  
  <script type="module">
    import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';

    const sequence = [
      {
        eventType: 'createNode',
        nodeId: 0,
        nodeType: 'Synth',
        args: { oscillator: { type: 'sine' } }
      },
      {
        eventType: 'connect',
        nodeId: 0,
        connectTo: 'toDestination'
      },
      {
        eventType: 'triggerAttackRelease',
        nodeId: 0,
        args: ['C4', '4n', '0']
      }
    ];

    const nodes = new SequencerNodes();

    document.getElementById('playButton').addEventListener('click', async () => {
      await Tone.start();
      await playSequence(Tone, nodes, sequence);
    });
  </script>
</body>
</html>
```

## `dist/` Directory Structure

The `dist/` directory contains the following files:

- `index.mjs` - Entry point in ES Modules format
- `index.js` - Entry point in CommonJS format
- `index.d.ts` - TypeScript type definition file
- `esm/` - Compiled files in ES Modules format
- `cjs/` - Compiled files in CommonJS format

You can choose the appropriate file format based on your project requirements.

## Samples

For more detailed usage examples, please refer to the `examples/` directory:

- `examples/cdn-example.html` - Browser usage example with CDN
- `examples/npm-example.mjs` - Usage example as an npm package

## NDJSON Streaming

`tonejs-json-sequencer` supports NDJSON (Newline Delimited JSON) streaming for real-time playback, live editing, and looping.

### Features

- **Live Editing**: Sequences can be edited during playback - changes are reflected in real-time without restarting.
- **Loop Playback**: Sequences automatically loop when they end.
- **50ms Lookahead**: Events are scheduled 50ms in advance for smooth and precise playback.

### Basic Usage

```typescript
import * as Tone from 'tone';
import { SequencerNodes, NDJSONStreamingPlayer } from 'tonejs-json-sequencer';

// Create a node manager
const nodes = new SequencerNodes();

// Create a streaming player with settings
const player = new NDJSONStreamingPlayer(Tone, nodes, {
  lookaheadMs: 50,    // Lookahead time (milliseconds)
  loop: true,         // Enable loop playback
  onLoopComplete: () => {
    console.log('Loop complete!');
  }
});

// Start playback with an NDJSON string or event array
const ndjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["C4","8n","0"]}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["E4","8n","0:0:2"]}
`;

await Tone.start();
await player.start(ndjson);

// Update sequence during playback (live editing)
const updatedNdjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["G4","8n","0"]}
`;
await player.start(updatedNdjson);  // Update without stopping

// Stop playback
player.stop();
```

### Demo

For a complete interactive demo of live editing and loop playback, please refer to `streaming.html`.

# Tone.js Component JSON Compatibility

`tonejs-json-sequencer` allows major Tone.js components to be described in JSON.

## Compatibility Overview

### Currently Supported (‚úÖ)

- **Instrument**: Synth, MonoSynth, FMSynth, AMSynth, DuoSynth, MetalSynth, MembraneSynth, PluckSynth, NoiseSynth, PolySynth, Sampler
- **Effect**: Reverb, Freeverb, JCReverb, Chorus, Phaser, Tremolo, Vibrato, AutoFilter, AutoPanner, AutoWah, FeedbackDelay, PingPongDelay, Distortion, BitCrusher, Chebyshev, PitchShift, FrequencyShifter, StereoWidener

### Planned (üöß)

- **Source**: FatOscillator, PulseOscillator
- **Effect**: EQ3 (Equalizer), Compressor
- **Performance Methods**: Panpot change, Expression change, LPF change, Portamento

### Future Consideration (‚è≥)

- **Source**: Oscillator, OmniOscillator, Noise, Player, GrainPlayer, others
- **Effect**: Filter series, Dynamics series (Limiter, Gate), Spatial series (Convolver), others
- **Component**: Envelope series, LFO, Signal series, Analysis series (Meter, Analyser, FFT), others

## Detailed Documentation

For detailed compatibility status of all components, implementation priorities, and implementation policies, please refer to the following document:

üìÑ [Tone.js Components JSON Compatibility Roadmap (Detailed Version)](docs/tonejs-components-roadmap.ja.md)

This document includes the following information:
- Classification and implementation status of all components (Instrument / Source / Effect / Component)
- Implementation priorities and plans
- Implementation policy and approach
- Links to reference materials

# Roadmap for Unimplemented JSON Events

This section lists features that are "possible with Tone.js but not yet implemented as JSON events."

## Currently Implemented JSON Events

- `createNode` - Create synth or effect nodes
- `connect` - Connect nodes
- `triggerAttackRelease` - Trigger notes
- `depth.rampTo` - Smooth change of depth parameter
- `volume.rampTo` - Smooth change of volume parameter
- `set` - Global settings (currently only supports `Transport.bpm.value`)
- `loopEnd` - Mark explicit loop boundary for streaming playback (metadata event)

## List of Unimplemented Features

### High Priority: JSON Events Required for Performance Expression

These are important features that directly affect performance expression.

#### Panpot (Panning) Control ‚è≥
- **Overview**: Real-time change of stereo positioning (L/R)
- **Required JSON Events**:
  - `pan.rampTo` - Smooth change of pan
  - `pan.value` - Immediate change of pan
- **Tone.js Implementation**: Controlled via Param API through compatible nodes with `.pan` parameter such as `PanVol` / `Panner`
- **Use Case Example**: Dynamically change L/R in a sequence phrase

#### LPF Cutoff Frequency and Resonance Control ‚è≥
- **Overview**: Real-time change of low-pass filter cutoff frequency and Q value
- **Required JSON Events**:
  - `filter.frequency.rampTo` - Smooth change of cutoff frequency
  - `filter.Q.rampTo` - Smooth change of resonance (Q value)
  - `filter.frequency.value` - Immediate change of cutoff frequency
  - `filter.Q.value` - Immediate change of resonance (Q value)
- **Tone.js Implementation**: Supported by filter-equipped synths like MonoSynth
- **Use Case Example**: Open/close filter within a phrase, long sweeps, attack-linked filter envelope

#### Pitch Control (Portamento/Pitch Envelope) ‚è≥
- **Overview**: Smoothly change pitch
- **Required JSON Events**:
  - `frequency.rampTo` - Smooth change of frequency (portamento)
  - `detune.rampTo` - Smooth change of detune (pitch envelope)
- **Tone.js Implementation**: Frequency/detune parameters of oscillators and synths
- **Use Case Example**: Portamento, pitch envelope at attack time (-200 cents ‚Üí 0 cents, etc.)

#### Expression Control ‚è≥
- **Overview**: Dynamically control volume and other parameters
- **Required JSON Events**:
  - (Short term) Add individual events for main parameters like volume.
  - (Medium-long term) Generic parameter access mechanism.
  - Example: `<nodeId>.<paramPath>.rampTo` format (assuming `paramPath` itself is whitelisted and supported paths are enumerated).
- **Design Policy / Roadmap**:
  - Continue with the **whitelist approach using `switch-case` for node IDs**.
  - If `<nodeId>.<paramPath>.rampTo` is introduced, `paramPath` will **only allow predefined paths**, not arbitrary strings.
  - First, increase individual events and identify necessary patterns, then consider a generic mechanism with enumerated supported paths.
- **Tone.js Implementation**: All Param objects support `rampTo`.
- **Use Case Example**: Increase/decrease expression within a phrase, changes in dynamics.

### Medium Priority: Effect Parameter Control

#### Reverb Parameters ‚è≥
- **Required JSON Events**: `decay.rampTo`, `wet.rampTo`, etc.
- **Use Case**: Dynamically change reverb depth and room size.

#### Chorus Parameters ‚è≥
- **Required JSON Events**: `frequency.rampTo`, `depth.rampTo` (Chorus specific)
- **Use Case**: Dynamically change chorus rate and depth.

#### Delay Parameters ‚è≥
- **Required JSON Events**: `delayTime.rampTo`, `feedback.rampTo`, etc.
- **Use Case**: Dynamically change delay time and feedback amount.

#### Phaser Parameters ‚è≥
- **Required JSON Events**: `frequency.rampTo`, `octaves.rampTo`, `Q.rampTo`, etc.
- **Use Case**: Long phaser sweeps, modulation for pads.

#### EQ (Equalizer) Parameters ‚è≥
- **Required JSON Events**: `low.rampTo`, `mid.rampTo`, `high.rampTo`, etc.
- **Use Case**: Adjust level for each frequency band.

#### Compressor Parameters ‚è≥
- **Required JSON Events**: `threshold.rampTo`, `ratio.rampTo`, `attack.rampTo`, `release.rampTo`, etc.
- **Use Case**: Dynamic adjustment of dynamics processing.

### Low Priority: Advanced Features

#### Envelope Control ‚è≥
- **Required JSON Events**: Access to ADSR parameters
- **Use Case**: Dynamic changes to envelope shape

#### LFO Parameters ‚è≥
- **Required JSON Events**: Control of LFO frequency, depth, and waveform
- **Use Case**: Dynamic changes to modulation

#### 3D Panning ‚è≥
- **Required JSON Events**: 3D spatial positioning control
- **Use Case**: Realization of spatial audio

## Confirmation of Implemented Features

### Tempo (BPM) Control ‚úÖ
- **Implementation Status**: ‚úÖ **Implemented**
- **JSON Event**: `set` event with `nodeType: 'Transport.bpm.value'`
- **Example Usage**:
  ```json
  {
    "eventType": "set",
    "nodeId": 0,
    "nodeType": "Transport.bpm.value",
    "args": [120]
  }
  ```

### Delay Vibrato ‚úÖ
- **Implementation Status**: ‚úÖ **Implemented**
- **Method**: Using `depth.rampTo`

## Implementation Policy

1.  **Safety First**: Continue with the whitelist approach using `switch-case` without `eval` or similar.
2.  **Incremental Implementation**: Implement high-priority features sequentially.
3.  **Dogfooding**: Test implemented features by actually using them.

## References

- Detailed component compatibility status: [Tone.js Components JSON Compatibility Roadmap](docs/tonejs-components-roadmap.ja.md)
- Tone.js Official Documentation: https://tonejs.github.io/docs/

# Roadmap
- *(Order not fixed)*
- *(Later, it would be good to split into two types: a simple sample focused on one topic for ease of use, and a practical sample combining multiple topics to showcase strengths.)*
- Program
  - Done: NDJSON streaming with live editing and loop playback (see `streaming.html`)
- Structure
  - Done: Multitimbral, FM Bass, and Saw Chord
- Performance Techniques
  - Done: Delay vibrato
  - Pitch envelope: attack starts at -200 cents, then changes to 0 cents (not attack-linked, but independent like delay vibrato)
  - Sequence phrase that changes Panpot between L/R on the fly
  - Phrase that increases/decreases Expression on the fly
  - Phrase that increases/decreases LPF on the fly
- Effects
  - Reverb
  - Chorus
  - Delay
  - Phaser: Apply a long sweep to a synth pad; if not possible, make it visible in the title etc.
  - EQ
  - Compressor
- Lead
  - Done: SuperSaw timbre (FatOscillator)
  - Distortion, preferably a guitar sound with Pluck
  - Overdrive-like WaveShaper settings, preferably a guitar sound with Pluck
  - Radical synth lead using Chebyshev
  - FM lead with long decay and harmonic changes, typical shimmering FM lead; try using pulse for modulator and carrier; if not possible, make it visible in the title etc.
  - Ambient lead, pulse timbre, with subtly random pitch changes
  - Distinctive lead: attack-linked pitch envelope starting at -200 cents, then changing to 0 cents
  - Lead with constant portamento
- Sequence Timbres
  - PulseOscillator timbre with 12.5% pulse
  - PluckSynth timbre for acoustic guitar or harp
  - NoiseSynth with a filter to play pitched phrases
- Drum
  - Tone.js built-in Kick, Snare, Tom, Hi-Hat; if 909 Kick is not possible, make it visible in the title etc.
- Pad
  - Done: Thick synth pad with FatOscillator
  - FM Electric Piano
- Bass
  - Hard FM bass
  - Synth bass with a constant attack-linked filter envelope
  - Overdrive-like Saw synth bass with filter envelope, and the filter changes with a long sweep
- Add other clear and effective Tone.js sound samples as they are found. The above list is currently considered a good stopping point.

# Development Notes, Regularly Updated
- Integration with tonejs-mml-to-json
  - Postponed. Will consider after organizing `tonejs-json-sequencer` validation data.
- NDJSON streaming
  - Status: ‚úÖ **Implementation complete** (see `streaming.html` and `src/ndjson-streaming.ts`)
  - Implemented features:
    - Live editing: When the textarea is edited, the changes are reflected in real-time without re-playing, continuing the performance.
    - Loop playback: Plays from the beginning when the end is reached.
    - 50ms lookahead: Events are scheduled 50ms in advance for smooth playback.
  - Implementation details:
    - `NDJSONStreamingPlayer` class processes events at lookahead timing.
    - Continuous event processing using `requestAnimationFrame`.
    - `parseNDJSON` function supports both arrays and NDJSON strings.
    - Independent demo and dedicated source files placed in `streaming.html`.
- Do not use `Tone.Transport.schedule` yet
  - When I had an agent generate code, complex code was generated, but no improvement in the unnaturalness of the sound was confirmed.
  - Judged that it is premature and better to wait until test data is available.
  - Future outlook:
    - Implement a higher layer (tonejs-mml-to-json).
    - Create test data:
      - JSON that clearly shows rhythm fluctuations.
        - E.g., high-tempo phrases with arpeggios, chords, and bass.
    - Perform the following:
      - Play the JSON with `tonejs-json-sequencer` and confirm the fluctuations.
      - Implement `Tone.Transport.schedule` and test for fluctuation improvement.
      - Implement and test the method successfully used in `postmate-midi`:
        - Process the time description in JSON at a higher layer to specify real-time, and play it via NDJSON streaming.
        - As mentioned, specify +50msec in the future.

# Challenges Under Consideration
- Challenge: Manually writing `switch-case` statements is tedious.
  - Policy: Actually writing function calls in `switch-case` is safe and simple, so we will generally stick to this approach.
    - Concern: However, if the `switch-case` grows large in the future, there's a concern that it might become too heavy for a "lightweight library" concept in terms of communication speed.
      - Assumption: Therefore, including a mechanism that only uses function names in a whitelist is an option, but it increases complexity and the risk of security mistakes.
        - Postponed: This is a non-functional requirement, so it's better to consider it after dogfooding and identifying it as "too slow."
  - Analysis: Insufficient context for an agent to generate `switch-case` statements.
    - Example: Unclear if generation can cover `depth.rampTo` etc.
    - Example: Whether `depth.rampTo` is currently sufficient, and what other method chains exist for other performance techniques or timbres, requires dogfooding.
    - Assumption: Even if generation could cover everything, investigating during test `red` would be tedious (due to the vast amount of source code).
  - Countermeasure: Maintain the current implementation policy and proceed with dogfooding.
- Consideration of a timbre library
  - *Eventually, it might be spun off as a separate project, similar to tonejs-mml-to-json.*
  - Past challenges:
    - It's unclear what the full potential of Tone.js is in terms of sound when mastered.
      - "Mastered" here means within the scope of low-cost implementation, without external waveforms (soundfonts etc.) or external AudioWorklet.
      - For example, for Saw and Square waves, the potential sound character, presence of aliasing noise in high frequencies, and usefulness for FM connections are uninvestigated and unknown.
        - (As a reference, I asked ChatGPT (not independently verified), and it said Tone.js generates a waveform table for one loop during node creation, and aliasing noise appears around the Nyquist frequency for high frequencies.)
      - For example, for FM:
        - Since it uses frequency modulation instead of phase modulation and lacks feedback,
        - it cannot produce phase modulation-based sounds or feedback-based sounds,
        - but the potential of what timbres can be produced using which waveforms for modulator and carrier is uninvestigated and unknown.
      - For example, for SuperSaw:
        - How much additional development, such as effects, is needed to achieve a
        - practically typical SuperSaw sound?
        - A clearer roadmap and workflow would be beneficial.
      - For example, if we wanted to create a 1-loop, 64-sample, 8-bit waveform, Tone.js and Web Audio's mechanisms lack the interface for it; probably, the only way is to perform Fourier transform and generate `partials` parameters (if more is needed, only external waveforms or AudioWorklet suffice).
        - However, whether this is actually the case is uninvestigated and unknown.
      - For example, for Reverb / Chorus / Flanger / Phaser, it's unknown if at least an SC-88Pro level can be achieved due to insufficient investigation.
      - For example, for Distortion series, including Overdrive series, it's unknown if at least an SC-88Pro level can be achieved due to insufficient investigation.
      - The use case is "use with limitations; for educational and experimental purposes," so not being able to produce luxurious sounds is not critical.
        - The important point is that seeing "how much is possible? where is the sweet spot?" would enable smoother musical activity.
        - To elaborate, Tone.js and WebAudio are positioned more towards simple signal processing than instruments. Understanding this, the question is how much instrument-like work can be done at low cost.
        - "Low cost" here implies "if the technical stack and ecosystem soil like `tonejs-json-sequencer` become rich, can development be done at low cost by standing on the shoulders of giants?"
        - It's recognized that Tone.js is superior in overall capabilities.
        - That is, when choosing the browser as a free, open-source, multi-platform environment for musical activities, Tone.js is recognized as having superior overall capabilities.
  - Countermeasures:
    - If timbre library sharing becomes easy,
      - "This is the potential that can be achieved with low-cost methods"
      - will become easier to visualize.
  - Image:
    - Share examples like "You can create these timbres, apply these effects, and combine them to create practical sounds like this."
  - Benefits of a timbre library:
    - Expected to foster the Tone.js ecosystem.
        - A past challenge has been the lack of reusability of user outputs.
        - If an environment for sharing and collaborating on user outputs is created, their accumulation can allow future users to stand on the shoulders of giants.
          - This applies not only to timbres but to Web Audio in general.
  - Consideration of the timbre library layer:
    - Do not integrate into `tonejs-json-sequencer`.
    - Provide it at a higher layer, in a separate project.
  - How much to focus on the timbre library?
    - Under consideration.
    - If both the timbre library and a timbre editor are enriched, the ecosystem is likely to grow.
    - Prioritizing the creation of minimum necessary features for `tonejs-json-sequencer` is high.
      - Because the existence of features in `tonejs-json-sequencer` is a prerequisite for higher layers.
- Relation to "Why": Division of labor with DAWs
  - DAWs
    - For when song completion is prioritized.
    - For maximizing composition and arrangement efficiency.
    - Create high-quality songs quickly! Ultimate practicality!
    - Required non-functional requirements: low latency, no audio dropouts. Assumes use of high-performance machines.
  - `tonejs-json-sequencer`
    - *Alternatively, browsers, WebAudio, Tone.js, and general non-DAW music applications across multiple platforms.*
    - For experimentation:
      - New UI
      - New sounds, timbres, and songs using new methods
    - New experiences:
      - Inspiration for composition
    - Interactive experiences:
      - E.g., educational music toys
    - Required non-functional requirements: None.
      - Quick realization of functionality is desirable.
      - Multi-platform capability is desirable.

# Priorities
- Implement features with clear and understandable effects. For example, delay vibrato, multitimbral.
- Safety. Security. Injection prevention. Do not use `eval`, etc.

# Out of Scope
- Node ID assignment ‚Üí This will be handled by a higher layer, for example, `tonejs-mml-to-json` or a JSON post-processor at a lower layer.
- Generating delay vibrato on and off for all notes ‚Üí Similar to Node ID assignment.
- Other data processing within JSON ‚Üí Similar to Node ID assignment.
- Exhaustiveness. Completely covering all combinations of Tone.js classes and methods and method chains, and completely covering all patterns of function calls possible with Tone.js via JSON.
- High performance. Choosing unmaintainable logic to minimize processing time or source file size.

# Automatic English Translation
`README.md` is automatically generated from `README.ja.md` using Gemini's translation via GitHub Actions.