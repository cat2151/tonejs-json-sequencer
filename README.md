# tonejs-json-sequencer

<p align="left">
  <a href="https://deepwiki.com/cat2151/tonejs-json-sequencer"><img src="https://img.shields.io/badge/DeepWiki-Documentation-blue?logo=book" alt="DeepWiki"></a>
  <a href="README.ja.md"><img src="https://img.shields.io/badge/ðŸ‡¯ðŸ‡µ-Japanese-red.svg" alt="Japanese"></a>
  <a href="README.md"><img src="https://img.shields.io/badge/ðŸ‡ºðŸ‡¸-English-blue.svg" alt="English"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/demo/index.html"><img src="https://img.shields.io/badge/ðŸš€-Live%20Demo-brightgreen.svg" alt="Demo"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/demo/streaming.html"><img src="https://img.shields.io/badge/ðŸŽµ-Streaming%20Demo-orange.svg" alt="Streaming Demo"></a>
</p>

# Status
- Frequent breaking changes are planned.
- This document and related documents may contain AI-generated content, and plans may be incorrect (differing from cat2151's original concept).

# Overview (in 3 lines)
- A lightweight library that allows describing Tone.js timbres, effects, and performances in JSON.
- Control sound with data instead of writing code, enabling seamless integration with UIs and streaming.
- Treat time-ordered events as data, allowing for intricate performance expressions.

# Why
- * This section was hastily generated by ChatGPT and may be rewritten in the future.
- * In fact, most of this is "planned for future implementation."

Tone.js is a library that enables rich musical expression on the web. It allows for advanced sound design in JavaScript, including building synthesizers, effect chains, and scheduling triggers.

However, due to its flexibility, the structure of timbres and patterns can often become deeply embedded in the program, making reuse and integration difficult.

tonejs-json-sequencer is a small mechanism that leverages Tone.js while externalizing timbre definitions, performance content, and timing information as JSON, enabling data-driven music playback.

A sequence is structured like SMF (Standard MIDI File), explicitly arranging all events in chronological order.

Timbres can be flexibly defined in JSON using Tone.js's synth/chain/params.

Dynamic changes to timbre parameters during playback allow for performance expressions like delayed vibrato and filter sweeps.

Directly accepts NDJSON streams from external tools or live generation engines for real-time playback.

This simply enables the manipulation, playback, and exchange of structured musical data via UI or network within Tone.js.

# Design Philosophy
- * This section was hastily generated by ChatGPT and may be rewritten in the future.

tonejs-json-sequencer adopts an approach where Tone.js components (synthesizers, effect chains, parameter changes, etc.) are directly described in JSON.

It avoids introducing unique music description languages or abstraction layers, delegating such advanced logic to higher program layers.

Timbre definitions specify constructor names like Tone.Synth or Tone.FMSynth and their argument objects.

Event definitions also have a structure similar to Tone.js method calls, such as triggerAttackRelease.

Parameter changes during playback are listed with function names, arguments, and event timestamps.

This achieves the goal of moving playback logic into data, making it configurable externally, without compromising Tone.js's sonic expressive power.

The core `scheduleOrExecuteEvent` is a simple source file that accepts a single element, with higher layers handling sequences and NDJSON streaming.

This allows for flexible, separate development of the low-level Tone.js integration and high-level sequence/streaming functionalities.

# Using as a Library

tonejs-json-sequencer can be used as a library in other projects.

## Installation

### Using npm

```bash
npm install tonejs-json-sequencer tone
```

### Referencing the dist/ Directory Directly

You can clone or download this repository and directly reference the files within the `dist/` directory.

#### ES Modules (Recommended)

```javascript
import { SequencerNodes, playSequence } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

#### CommonJS

```javascript
const { SequencerNodes, playSequence } = require('./path/to/tonejs-json-sequencer/dist/cjs/index.js');
```

#### TypeScript

When using TypeScript, type definition files are also included in the `dist/` directory:

```typescript
import { SequencerNodes, playSequence, SequenceEvent } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

Type definition file: `dist/index.d.ts`

### Using a CDN

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

Or using unpkg:

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://unpkg.com/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

## Basic Usage Example

```typescript
import * as Tone from 'tone';
import { SequencerNodes, playSequence } from 'tonejs-json-sequencer';

// Define sequence in JSON
const sequence = [
  {
    eventType: 'createNode',
    nodeId: 0,
    nodeType: 'Synth',
    args: { oscillator: { type: 'sine' } }
  },
  {
    eventType: 'connect',
    nodeId: 0,
    connectTo: 'toDestination'
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['C4', '8n', '0']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['E4', '8n', '0:0:2']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['G4', '8n', '0:1:0']
  }
];

// Create node manager
const nodes = new SequencerNodes();

// Play sequence
async function play() {
  await Tone.start();
  await playSequence(Tone, nodes, sequence);
}

// Bind to button click
document.getElementById('playButton').addEventListener('click', play);
```

## Browser Usage Example (using CDN)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Tonejs JSON Sequencer Example</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@15.0.4/build/Tone.js"></script>
</head>
<body>
  <button id="playButton">Play</button>
  
  <script type="module">
    import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';

    const sequence = [
      {
        eventType: 'createNode',
        nodeId: 0,
        nodeType: 'Synth',
        args: { oscillator: { type: 'sine' } }
      },
      {
        eventType: 'connect',
        nodeId: 0,
        connectTo: 'toDestination'
      },
      {
        eventType: 'triggerAttackRelease',
        nodeId: 0,
        args: ['C4', '4n', '0']
      }
    ];

    const nodes = new SequencerNodes();

    document.getElementById('playButton').addEventListener('click', async () => {
      await Tone.start();
      await playSequence(Tone, nodes, sequence);
    });
  </script>
</body>
</html>
```

## dist/ Directory Structure

The `dist/` directory contains the following files:

- `index.mjs` - ES Modules entry point
- `index.js` - CommonJS entry point
- `index.d.ts` - TypeScript type definition file
- `esm/` - Compiled files in ES Modules format
- `cjs/` - Compiled files in CommonJS format

You can choose the appropriate file format based on your project requirements.

## Examples

For more detailed usage examples, refer to the `examples/` directory:

- `examples/cdn-example.html` - Browser usage example using CDN
- `examples/npm-example.mjs` - Usage example as an npm package

## NDJSON Streaming

tonejs-json-sequencer supports NDJSON (Newline Delimited JSON) streaming for real-time playback with live editing and loop support.

### Features

- **Live Editing**: Edit the sequence while playing - changes are reflected in real-time without restarting playback
- **Loop Playback**: Automatically loop the sequence when it reaches the end
- **50ms Lookahead**: Events are scheduled 50ms ahead for smooth, precise playback

### Basic Usage

```typescript
import * as Tone from 'tone';
import { SequencerNodes, NDJSONStreamingPlayer } from 'tonejs-json-sequencer';

// Create nodes manager
const nodes = new SequencerNodes();

// Create streaming player with configuration
const player = new NDJSONStreamingPlayer(Tone, nodes, {
  lookaheadMs: 50,    // Lookahead time in milliseconds
  loop: true,         // Enable loop playback
  onLoopComplete: () => {
    console.log('Loop completed!');
  }
});

// Start playback with NDJSON string or event array
const ndjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["C4","8n","0"]}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["E4","8n","0:0:2"]}
`;

await Tone.start();
await player.start(ndjson);

// Update sequence during playback (live editing)
const updatedNdjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["G4","8n","0"]}
`;
await player.start(updatedNdjson);  // Updates without stopping

// Stop playback
player.stop();
```

### Demo

See `demo/streaming.html` for a complete interactive demo with live editing and loop playback.

# JSON Support for Tone.js Components

tonejs-json-sequencer enables describing major Tone.js components in JSON.

## Status Overview

### Currently Supported (âœ…)

- **Instrument**: Synth, MonoSynth, FMSynth, AMSynth, DuoSynth, MetalSynth, MembraneSynth, PluckSynth, NoiseSynth, PolySynth, Sampler
- **Effect**: Reverb, Freeverb, JCReverb, Chorus, Phaser, Tremolo, Vibrato, AutoFilter, AutoPanner, AutoWah, FeedbackDelay, PingPongDelay, Distortion, BitCrusher, Chebyshev, PitchShift, FrequencyShifter, StereoWidener

### Planned (ðŸš§)

- **Source**: FatOscillator, PulseOscillator
- **Effect**: EQ3 (Equalizer), Compressor
- **Performance Methods**: Panpot change, Expression change, LPF change, Portamento

### Under Consideration (â³)

- **Source**: Oscillator, OmniOscillator, Noise, Player, GrainPlayer, etc.
- **Effect**: Filter-related, Dynamics-related (Limiter, Gate), Spatial-related (Convolver), etc.
- **Component**: Envelope-related, LFO, Signal-related, Analysis-related (Meter, Analyser, FFT), etc.

## Detailed Documentation

For detailed support status, implementation priorities, and policies for all components, please refer to the following document:

ðŸ“„ [Tone.js Component JSON Support Roadmap (Detailed)](docs/tonejs-components-roadmap.ja.md)

This document includes the following information:
- Classification and implementation status of all components (Instrument / Source / Effect / Component)
- Implementation priorities and plans
- Implementation policy and approach
- Links to reference materials

# Roadmap
- * Order is not fixed.
- * Later, it might be good to split into two types of samples: a simple one focused on a single topic for ease of use, and a practical one combining multiple topics to clearly showcase strengths.
- Programming
  - Done : NDJSON streaming with live editing and loop playback (see demo/streaming.html)
- Structure
  - Done : Multitimbral, FM Bass, and Saw Chord
- Performance Techniques
  - Done : Delayed vibrato
  - Pitch envelope: changes from -200 cents at attack to 0 cents * (not attack-linked, but independent like delayed vibrato)
  - Sequence phrase to change panpot (L/R) on the fly.
  - Phrase to increase/decrease expression on the fly.
  - Phrase to increase/decrease LPF on the fly.
- Effects
  - Reverb
  - Chorus
  - Delay
  - Phaser: Apply a long sweep to a synth pad. If not feasible, visualize it in the title, etc.
  - EQ
  - Compressor
- Lead Sounds
  - Done : SuperSaw timbre (FatOscillator)
  - Distortion: Ideally a guitar sound with PluckSynth.
  - Overdrive-like WaveShaper settings: Ideally a guitar sound with PluckSynth.
  - Aggressive synth lead using Chebyshev.
  - FM lead with long decay and overtone changes; typical glittering FM lead; try pulse for modulator and carrier. If not feasible, visualize it in the title, etc.
  - Ambient lead: pulse timbre with subtle, random pitch variations.
  - Distinctive lead: attack-linked pitch envelope, changing from -200 cents at attack to 0 cents.
  - Lead with constant portamento.
- Sequence Timbres
  - PulseOscillator timbre with 12.5% pulse.
  - PluckSynth timbre for acoustic guitar or harp.
  - NoiseSynth with a filter to play pitched phrases.
- Drums
  - Tone.js built-in Kick, Snare, Tom, Hi-Hat. If a 909 Kick isn't feasible, visualize it in the title, etc.
- Pad Sounds
  - Done : Thick synth pad with FatOscillator.
  - FM Electric Piano.
- Bass Sounds
  - Hard FM bass.
  - Synth bass with a constant attack-linked filter envelope.
  - Overdrive-like Saw synth bass with a filter envelope and a long filter sweep.
- Other Tone.js samples that clearly demonstrate sounds will be added as found. For now, the above list is complete.

# Development Notes (Regularly Updated)
- Integration with tonejs-mml-to-json
  - Postponed. Will consider after organizing verification data for tonejs-json-sequencer.
- NDJSON streaming
  - Status: âœ… **Implemented** (see `demo/streaming.html` and `src/ndjson-streaming.ts`)
  - Features implemented:
    - Live editing: When a textarea is edited, the changes are reflected without restarting playback, continuing the performance.
    - Loop playback: When the end is reached, playback resumes from the beginning.
    - 50ms lookahead: Events are scheduled 50ms ahead for smooth playback.
  - Implementation details:
    - `NDJSONStreamingPlayer` class processes events with lookahead timing.
    - Uses `requestAnimationFrame` for continuous event processing.
    - Supports both array and NDJSON string input via `parseNDJSON` function.
    - Separate demo at `demo/streaming.html` with its own source file.
- Will not use Tone.Transport.schedule yet.
  - When I tried having an agent generate code, complex code was produced, but no improvement in the unnaturalness of sound generation was observed.
  - Decided it's premature; it's better to wait until test data is ready.
  - Future Outlook
    - Implement the higher layer (tonejs-mml-to-json).
    - Create test data.
      - JSON that clearly shows rhythmic instability.
        - e.g., high-tempo phrases with arpeggios, chords, and bass.
    - Perform the following:
      - Play that JSON with tonejs-json-sequencer and confirm the instability.
      - Implement Tone.Transport.schedule and test for instability improvement.
      - Implement and test the proven method successful with postmate-midi:
        - Process JSON time descriptions in a higher layer to specify real-time, then play with NDJSON streaming.
        - As mentioned, specify +50ms in the future.

# Issues Under Consideration
- Issue: Manually writing switch cases is tedious.
  - Policy: We will generally stick to writing function calls directly within switch cases, as it is safe and simple.
    - Concern: However, if the switch cases grow large, there's a concern that it might incur too much communication overhead for a lightweight library.
      - Assumption: Therefore, a mechanism to use only whitelisted function names is an option, though it would increase complexity and the risk of security errors.
        - Postpone: This is a non-functional requirement, so it's better to consider it after dogfooding reveals it's "too slow."
  - Analysis: Insufficient context for an agent to generate switch cases.
    - e.g., It's unclear if generation can cover methods like `depth.rampTo`.
    - e.g., Whether `depth.rampTo` is sufficient as is, and what other method chains exist for various performance techniques and timbres, requires dogfooding.
    - Assumption: Even if full coverage could be generated, investigating during test failures would be tedious (due to the vast source code).
  - Countermeasure: Maintain the current implementation policy and proceed with dogfooding.
- Consideration of a Timbre Library
  - * This might eventually be split off as a separate project, similar to tonejs-mml-to-json.
  - Past Issues
    - It's unclear what the full potential of Tone.js is in terms of sound output when mastered.
      - Here, "mastered" means within the scope of low-cost implementation, without external waveforms (like soundfonts) or external AudioWorklets.
      - For instance, the actual timbre characteristics of Saw and Square waves, the presence/absence of aliasing noise in high frequencies, and their utility in FM connections are still unknown and uninvestigated.
        - For reference, I asked ChatGPT (note: not independently verified) and it said Tone.js generates a waveform table for one loop during node creation, and aliasing noise can occur around the Nyquist frequency at high frequencies.
      - For instance, FM:
        - It uses frequency modulation, not phase modulation, and has no feedback, so:
        - It cannot produce phase modulation-based timbres or feedback-based timbres.
        - The potential for what waveforms can be used for modulators and carriers, and what timbres can be produced, is still unknown and uninvestigated.
      - For instance, SuperSaw:
        - How much additional effort, such as effects, is needed to:
        - Produce a practical, typical SuperSaw sound?
        - A clearer roadmap and workflow would be beneficial.
      - For example, to create a 64-sample, 8-bit waveform for one loop, Tone.js and Web Audio lack a direct interface for this. It seems the only method is likely to use Fourier transform to generate partials parameters (anything beyond that would require external waveforms or AudioWorklets), but:
        - Whether this is actually the case is still unknown and uninvestigated.
      - For example, Reverb / Chorus / Flanger / Phaser: Whether at least an SC-88Pro level can be achieved is still unknown due to insufficient investigation.
      - For example, Distortion-related effects, including Overdrive: Whether at least an SC-88Pro level can be achieved is still unknown due to insufficient investigation.
      - The intended use is "compromise. For educational and experimental purposes," so the inability to produce luxurious sounds is not particularly critical.
        - What's important is to clarify "what can be achieved, and where is the sweet spot?" to enable smoother musical activities.
        - To supplement, Tone.js and Web Audio are positioned more towards simple signal processing than instruments. Understanding this, there's also the perspective of how much instrument-like functionality can be achieved at low cost by making compromises.
        - "Low cost" here refers to the idea of whether, as the technology stack and ecosystem around tonejs-json-sequencer become richer, future developers can "stand on the shoulders of giants" and develop at low cost.
        - Note that Tone.js is recognized as superior in overall capability among available options.
        - In other words, when choosing the browser as a platform for free, open-source, multi-platform musical activities, Tone.js is recognized as superior in overall capability.
  - Countermeasures
    - If timbre library sharing becomes easy, then:
      - The potential achievable with low-cost methods would become clearer.
      - This would make it easier to visualize.
  - Concept
    - Share examples like "You can create these timbres, apply these effects, and combine them to achieve these practical sounds."
  - Benefits of a Timbre Library
    - It is expected to form the foundation of the Tone.js ecosystem.
        - A past issue has been the lack of reusability for individual user outputs.
        - If a foundation for sharing and linking individual user outputs can be established, their accumulation would allow the next generation of users to "stand on the shoulders of giants."
          - This applies not only to timbres but to Web Audio in general.
  - Consideration of the Timbre Library's Layer
    - Not integrated into tonejs-json-sequencer, but:
    - Prepared in a higher layer, a separate project.
  - How much focus on the timbre library?
    - Under consideration.
    - If both the timbre library and timbre editor are robust, the ecosystem is more likely to grow.
    - Developing minimum essential features for tonejs-json-sequencer has high priority.
      - Because the existence of functionality in tonejs-json-sequencer is a prerequisite for higher layers.
- Related to "Why": Distinction from DAWs
  - DAW (Digital Audio Workstation)
    - For prioritizing song completeness.
    - For maximizing composition and arrangement efficiency.
    - Quickly create high-quality songs! Ultimate practicality!
    - Required non-functional application requirements are low latency, no audio dropouts. Assumes use of high-performance machines.
  - tonejs-json-sequencer
    - * Or, generally, non-DAW music applications on browsers, WebAudio, Tone.js, multi-platform.
    - For experimentation:
      - New UI
      - New sounds, timbres, and songs using new methods.
    - New experiences:
      - Inspiration for composition.
    - Interactive experiences:
      - e.g., educational music toys.
    - No non-functional requirements.
      - Quick feature implementation is desirable.
      - Multi-platform compatibility is desirable.

# Priorities
- Implementation of clearly effective features. For example, delayed vibrato, multitimbral.
- Safety, security, injection countermeasures. Do not use eval, etc.

# Out of Scope
- `nodeId` assignment -> Handled by higher layers, e.g., tonejs-mml-to-json or a lower-layer JSON post-processor.
- Generating delayed vibrato on/off for all notes -> Similar to `nodeId` assignment.
- Other data processing within JSON -> Similar to `nodeId` assignment.
- Comprehensiveness: Fully covering all Tone.js classes, methods, method chain combinations, and all patterns of function calls achievable with Tone.js via JSON.
- High performance: Choosing hard-to-maintain logic to minimize processing time or source file size.

# Automatic Translation
README.md is automatically generated from README.ja.md using Gemini's translation via GitHub Actions.