# tonejs-json-sequencer

<p align="left">
  <a href="https://deepwiki.com/cat2151/tonejs-json-sequencer"><img src="https://img.shields.io/badge/DeepWiki-Documentation-blue?logo=book" alt="DeepWiki"></a>
  <a href="README.ja.md"><img src="https://img.shields.io/badge/üáØüáµ-Japanese-red.svg" alt="Japanese"></a>
  <a href="README.md"><img src="https://img.shields.io/badge/üá∫üá∏-English-blue.svg" alt="English"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/index.html"><img src="https://img.shields.io/badge/üöÄ-Live%20Demo-brightgreen.svg" alt="Demo"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/streaming.html"><img src="https://img.shields.io/badge/üéµ-Streaming%20Demo-orange.svg" alt="Streaming Demo"></a>
</p>

# Status
- Frequent breaking changes are expected.
- This document and related documents may contain AI-generated content, and plans (which may differ from cat2151's vision) could be incorrect.

# Explained in 3 lines
- A lightweight library that allows describing Tone.js timbres, effects, and performances using JSON.
- Control sound with data without writing code, enabling seamless integration with UIs and streaming.
- Handle time-ordered events as data, allowing for intricate performance expressions.

# Why
- *This section was quickly generated by ChatGPT. It may be rewritten in the future.*
- *Actually, most of it is "to be implemented in the future."*

Tone.js is a library that enables rich musical expression on the web. It allows for advanced sound design, such as building synths, effect chains, and scheduling triggers, freely in JavaScript.

However, due to its flexibility, timbre and pattern structures can become deeply embedded in the program, making reuse and integration difficult.

tonejs-json-sequencer is a small mechanism that leverages Tone.js while externalizing timbre definitions, performance content, and timing information as JSON, enabling data-driven music playback.

Sequences are structured like SMF, explicitly listing all events in chronological order.

Timbres can be flexibly defined in JSON using Tone.js's synth/chain/params.

Dynamic changes to timbre parameters are possible during performance, allowing for expressive techniques like delayed vibrato or filter sweeps.

It can directly receive NDJSON streams from external tools or live generation engines for real-time playback.

This enables a simple way to manipulate, play, and exchange structured music data over UIs or networks using Tone.js.

# Design Philosophy
- *This section was quickly generated by ChatGPT. It may be rewritten in the future.*

tonejs-json-sequencer adopts an approach where Tone.js components (synths, effect chains, parameter changes, etc.) are directly described in JSON.

It does not introduce its own music description language or abstraction layer; instead, such higher-level logic is delegated to the upper program layers.

Timbre definitions specify Tone.Synth or Tone.FMSynth constructor names and argument objects.

Event definitions also have a structure similar to Tone.js calls like `triggerAttackRelease`.

Parameter changes during performance are listed as function names and arguments, along with event timestamps.

This achieves the goal of shifting playback logic to data, making it configurable externally, without compromising the acoustic expressive power of Tone.js.

The core `scheduleOrExecuteEvent` is a simple source file that accepts a single element, while higher layers handle sequences and NDJSON streaming.

This allows for flexible development by separating the low-level connection to Tone.js from higher-level concepts like sequencing and streaming.

# Usage as a Library

tonejs-json-sequencer can be used as a library in other projects.

## Installation

### Using npm

```bash
npm install tonejs-json-sequencer tone
```

### Directly referencing the `dist/` directory

You can clone or download this repository and directly reference the files in the `dist/` directory.

#### ES Modules (Recommended)

```javascript
import { SequencerNodes, playSequence } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

#### CommonJS

```javascript
const { SequencerNodes, playSequence } = require('./path/to/tonejs-json-sequencer/dist/cjs/index.js');
```

#### TypeScript

If you are using TypeScript, the type definition files are also included in the `dist/` directory:

```typescript
import { SequencerNodes, playSequence, SequenceEvent } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

Type definition file: `dist/index.d.ts`

### Using CDN

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

Or using unpkg:

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://unpkg.com/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

## Basic Usage Example

```typescript
import * as Tone from 'tone';
import { SequencerNodes, playSequence } from 'tonejs-json-sequencer';

// Define the sequence in JSON
const sequence = [
  {
    eventType: 'createNode',
    nodeId: 0,
    nodeType: 'Synth',
    args: { oscillator: { type: 'sine' } }
  },
  {
    eventType: 'connect',
    nodeId: 0,
    connectTo: 'toDestination'
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['C4', '8n', '0']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['E4', '8n', '0:0:2']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['G4', '8n', '0:1:0']
  }
];

// Create a node manager
const nodes = new SequencerNodes();

// Play the sequence
async function play() {
  await Tone.start();
  await playSequence(Tone, nodes, sequence);
}

// Bind to button click
document.getElementById('playButton').addEventListener('click', play);
```

## Browser Usage Example (using CDN)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Tonejs JSON Sequencer Example</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@15.0.4/build/Tone.js"></script>
</head>
<body>
  <button id="playButton">Play</button>
  
  <script type="module">
    import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';

    const sequence = [
      {
        eventType: 'createNode',
        nodeId: 0,
        nodeType: 'Synth',
        args: { oscillator: { type: 'sine' } }
      },
      {
        eventType: 'connect',
        nodeId: 0,
        connectTo: 'toDestination'
      },
      {
        eventType: 'triggerAttackRelease',
        nodeId: 0,
        args: ['C4', '4n', '0']
      }
    ];

    const nodes = new SequencerNodes();

    document.getElementById('playButton').addEventListener('click', async () => {
      await Tone.start();
      await playSequence(Tone, nodes, sequence);
    });
  </script>
</body>
</html>
```

## `dist/` Directory Structure

The `dist/` directory contains the following files:

- `index.mjs` - Entry point for ES Modules format
- `index.js` - Entry point for CommonJS format
- `index.d.ts` - TypeScript type definition file
- `esm/` - Compiled files in ES Modules format
- `cjs/` - Compiled files in CommonJS format

You can choose the appropriate file format based on your project requirements.

## Samples

For more detailed usage examples, please refer to the `examples/` directory:

- `examples/cdn-example.html` - Browser usage example using CDN
- `examples/npm-example.mjs` - Usage example as an npm package

## NDJSON Streaming

tonejs-json-sequencer supports NDJSON (Newline Delimited JSON) streaming for real-time playback, live editing, and loop playback.

### Features

- **Live Editing**: Edit the sequence during playback ‚Äì changes are reflected in real-time without restarting.
- **Loop Playback**: The sequence automatically loops when it ends.
- **50ms Lookahead**: Events are scheduled 50ms in advance for smooth and accurate playback.

### Basic Usage

```typescript
import * as Tone from 'tone';
import { SequencerNodes, NDJSONStreamingPlayer } from 'tonejs-json-sequencer';

// Create a node manager
const nodes = new SequencerNodes();

// Create a streaming player with settings
const player = new NDJSONStreamingPlayer(Tone, nodes, {
  lookaheadMs: 50,    // Lookahead time (milliseconds)
  loop: true,         // Enable loop playback
  onLoopComplete: () => {
    console.log('Loop complete!');
  }
});

// Start playback with an NDJSON string or an array of events
const ndjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["C4","8n","0"]}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["E4","8n","0:0:2"]}
`;

await Tone.start();
await player.start(ndjson);

// Update sequence during playback (live editing)
const updatedNdjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["G4","8n","0"]}
`;
await player.start(updatedNdjson);  // Update without stopping

// Stop playback
player.stop();
```

### Demo

For a complete interactive demo of live editing and loop playback, please refer to `streaming.html`.

# JSON Support for Tone.js Components

tonejs-json-sequencer enables describing key Tone.js components using JSON.

## Status Overview

### Currently Supported (‚úÖ)

- **Instrument**: Synth, MonoSynth, FMSynth, AMSynth, DuoSynth, MetalSynth, MembraneSynth, PluckSynth, NoiseSynth, PolySynth, Sampler
- **Effect**: Reverb, Freeverb, JCReverb, Chorus, Phaser, Tremolo, Vibrato, AutoFilter, AutoPanner, AutoWah, FeedbackDelay, PingPongDelay, Distortion, BitCrusher, Chebyshev, PitchShift, FrequencyShifter, StereoWidener

### Planned (üöß)

- **Source**: FatOscillator, PulseOscillator
- **Effect**: EQ3 (Equalizer), Compressor
- **Performance Methods**: Panpot change, Expression change, LPF change, Portamento

### To Be Considered (‚è≥)

- **Source**: Oscillator, OmniOscillator, Noise, Player, GrainPlayer, etc.
- **Effect**: Filter series, Dynamics series (Limiter, Gate), Spatial series (Convolver), etc.
- **Component**: Envelope series, LFO, Signal series, Analysis series (Meter, Analyser, FFT), etc.

## Detailed Documentation

For a detailed status of all components, implementation priorities, and policies, please refer to the following document:

üìÑ [Tone.js Component JSON Support Roadmap (Detailed)](docs/tonejs-components-roadmap.ja.md)

This document includes the following information:
- Classification and implementation status of all components (Instrument / Source / Effect / Component)
- Implementation priorities and plans
- Implementation policy and approach
- Links to reference materials

# Roadmap
- *Order is not fixed.*
- *Later, it would be good to split into two types: a simple sample focused on one topic for ease of use, and a practical sample combining multiple topics to highlight strengths.*
- Program
  - ‚úÖ Implemented: NDJSON streaming with live editing and loop playback (see streaming.html)
- Structure
  - ‚úÖ Implemented: Multitimbral, FM Bass, and Saw Chord
- Performance Techniques
  - ‚úÖ Implemented: Delayed vibrato
  - Pitch envelope where attack is -200 cents, then changes to 0 cents * (not linked to attack, but independent like delayed vibrato)
  - Sequence phrase that changes Panpot on the fly (L/R)
  - Phrase that increases/decreases Expression on the fly
  - Phrase that increases/decreases LPF on the fly
- Effect
  - Reverb
  - Chorus
  - Delay
  - Phaser, applying a long sweep to a synth pad (if not possible, make it visible in the title etc.)
  - EQ
  - Compressor
- Lead
  - ‚úÖ Implemented: SuperSaw timbre (FatOscillator)
  - Distortion, ideally with Pluck for guitar
  - Overdrive-like WaveShaper settings, ideally with Pluck for guitar
  - Extreme synth lead using Chebyshev
  - FM lead with long decay and overtone changes, typical shimmering FM lead; try pulse for modulator and carrier (if not possible, make it visible in the title etc.)
  - Ambient lead, pulse timbre, slightly random, subtle pitch variations
  - Peculiar lead, pitch envelope linked to attack where attack is -200 cents, then changes to 0 cents
  - Lead with constant portamento
- Sequence Timbres
  - PulseOscillator timbre with 12.5% pulse
  - PluckSynth timbre for acoustic guitar or harp
  - NoiseSynth with a filter to play melodic phrases
- Drum
  - Tone.js built-in Kick, Snare, Tom, Hi-Hat; if 909 Kick is not possible, state it in the title etc.
- Pad
  - ‚úÖ Implemented: Thick synth pad with FatOscillator
  - FM electric piano
- Bass
  - Hard FM bass
  - Synth bass with a constant attack-linked filter envelope
  - Overdrive-like Saw synth bass, with filter envelope, and the filter changes with a long sweep
- Will add more clear-sounding Tone.js samples as they are found. For now, the above covers the current phase.

# Development Notes, Regularly Updated
- Integration with tonejs-mml-to-json
  - Postponed. Will consider after organizing the verification data for tonejs-json-sequencer.
- NDJSON streaming
  - Status: ‚úÖ **Implementation Complete** (See `streaming.html` and `src/ndjson-streaming.ts`)
  - Implemented features:
    - Live editing: When editing the textarea, the changes are reflected in real-time without restarting playback.
    - Loop playback: Plays from the beginning when the end is reached.
    - 50ms lookahead: Events are scheduled 50ms in advance for smooth playback.
  - Implementation details:
    - `NDJSONStreamingPlayer` class processes events with lookahead timing.
    - Continuous event processing using `requestAnimationFrame`.
    - `parseNDJSON` function supports both arrays and NDJSON strings.
    - Dedicated demo and source files located in `streaming.html`.
- Do not use `Tone.Transport.schedule` yet.
  - When I had an agent generate code, complex code was produced, but no improvement in playback irregularity was observed.
  - Judging it premature, it's better to wait until test data is available.
  - Future Outlook:
    - Implement a higher layer (tonejs-mml-to-json).
    - Create test data.
      - JSON that clearly shows rhythmic instability (e.g., high-tempo phrases with arpeggios, chords, bass).
    - Perform the following:
      - Play that JSON with tonejs-json-sequencer and confirm the instability.
      - Implement `Tone.Transport.schedule` and test for instability improvement.
      - Implement and test the method successfully used in postmate-midi:
        - Process the time descriptions in JSON in a higher layer to specify real-time, then play with NDJSON streaming.
        - As mentioned above, specify +50ms into the future.

# Issues Under Consideration
- Issue: Manually writing switch cases is tedious.
  - Policy: Writing actual function calls with switch cases is safe and simple, so we will generally stick to this approach.
    - Concern: However, if the switch case grows large in the future, there's a concern about high communication speed for a lightweight library.
      - Assumption: Therefore, a mechanism that only uses function names on a whitelist is an option, but it increases complexity and the risk of security errors.
        - Postponed: This is a non-functional requirement, so it's better to consider it after dogfooding and finding it "too slow."
  - Analysis: Insufficient context for an agent to generate switch cases.
    - Example: Unclear if `depth.rampTo` etc. can be fully covered by generation.
    - Example: Unclear if `depth.rampTo` is sufficient as is, or what other method chains exist for other performance techniques or timbres. Dogfooding is necessary.
    - Assumption: Even if all coverage could be generated, investigating during test `red` would be tedious (due to voluminous source code).
  - Countermeasure: Maintain the current implementation policy and proceed with dogfooding.
- Consideration of a timbre library
  - *Eventually, like tonejs-mml-to-json, this might be split off as a separate project idea.*
  - Past issues:
    - It's unclear what the full potential of Tone.js is when used proficiently.
      - "Proficiently" here means within the scope of low-cost implementation, without external waveforms (soundfonts, etc.) or external AudioWorklets.
      - For example, with Saw or Square waves, the actual timbre characteristics, presence/absence of aliasing noise in high frequencies, and usefulness for FM connections are uninvestigated and still unknown.
        - For reference, according to ChatGPT (not independently verified), Tone.js generates a waveform table for one loop during node creation, so aliasing noise appears around the Nyquist frequency at high frequencies.
      - For example, with FM:
        - Since it uses frequency modulation rather than phase modulation and has no feedback,
        - Phase modulation or feedback-based timbres cannot be produced, but
        - The potential to produce timbres using various modulator and carrier waveforms is uninvestigated and still unknown.
      - For example, with SuperSaw:
        - How much additional crafting, like effects, is needed to achieve a practical, typical SuperSaw?
        - A clearer roadmap and workflow would be beneficial.
      - For example, to create a 1-loop 64-sample, 8-bit waveform, there's no interface in Tone.js or Web Audio, and probably the only method is to generate partials parameters via Fourier transform (if more is needed, only external waveforms or AudioWorklets exist), but
        - Whether this is actually the case is uninvestigated and still unknown.
      - For example, Reverb / Chorus / Flanger / Phaser: Is it possible to achieve at least SC-88Pro level? This is still unclear due to insufficient investigation.
      - For example, Distortion / Overdrive series: Is it possible to achieve at least SC-88Pro level? This is still unclear due to insufficient investigation.
      - Since the use case is "compromise. For educational and experimental purposes," not being able to produce luxurious sounds is not critical.
        - The important point is that seeing "what can be achieved? Where is the sweet spot?" would enable smoother musical activities.
        - To clarify, Tone.js and WebAudio are positioned more towards simple signal processing than musical instruments. With that understanding, the question is how much can be done musically at low cost.
        - "Low cost" here means "if the technology stack and ecosystem (like tonejs-json-sequencer) mature, can development be done at low cost by standing on the shoulders of giants?"
        - It is recognized that Tone.js generally excels in overall capabilities.
        - That is, when choosing the browser as a free, open-source, multi-platform environment for musical activities, Tone.js is recognized as superior in overall capability.
  - Countermeasures:
    - If timbre library sharing becomes easy,
      - The potential that can be demonstrated with low-cost methods will become more visible.
  - Image:
    - Share examples of "these timbres can be created," "these effects can be applied," and "combining them yields this level of practical sound."
  - Benefits of a timbre library:
    - It is expected to become fertile ground for the Tone.js ecosystem.
        - A past issue is the lack of reusability of each user's output.
        - If an environment for sharing and collaborating on each user's output can be created, its accumulation could enable future users to stand on the shoulders of giants.
          - This applies not only to timbres but to Web Audio in general.
  - Consideration of the layer for the timbre library:
    - Not integrated into tonejs-json-sequencer, but
    - Provided at a higher layer, as a separate project.
  - How much to focus on the timbre library?
    - Under consideration.
    - If both timbre libraries and timbre editors are enriched, the ecosystem is likely to grow.
    - The priority for creating minimum functionality in tonejs-json-sequencer is high.
      - Because the functionality in tonejs-json-sequencer is a prerequisite for higher layers.
- Distinction from DAWs (related to Why)
  - DAWs
    - For prioritizing the completeness of a song.
    - For maximizing composition and arrangement efficiency.
    - Quick creation of high-quality music! Ultimate practicality!
    - Required non-functional requirements: low latency, no audio dropouts. Assumes use of high-performance machines.
  - tonejs-json-sequencer
    - *Or rather, all non-DAW music apps on browsers, WebAudio, Tone.js, multi-platform.*
    - For experimentation
      - New UIs
      - New sounds, timbres, and music with new methods
    - New experiences
      - Inspiration for composition
    - Interactive experiences
      - E.g., educational music toys
    - Required non-functional requirements: none.
      - Quick feature implementation is desirable.
      - Multi-platform support is desirable.

# Priorities
- Implementation of features with clear impact, e.g., delayed vibrato, multitimbral.
- Safety and security. Injection prevention. Avoid `eval` and similar.

# Out of Scope
- Node ID assignment ‚Üí Handled by higher layers, e.g., tonejs-mml-to-json or a lower-layer JSON post-processor.
- Generating delay vibrato on and off for all notes ‚Üí Similar to node ID assignment.
- Other JSON data processing ‚Üí Similar to node ID assignment.
- Comprehensive coverage. Completely covering all Tone.js classes, methods, and method chain combinations, and all patterns of function calls achievable via JSON in Tone.js.
- High performance. Choosing unmaintainable logic to minimize processing time or source file size.

# Automatic English Translation
README.md is automatically generated from README.ja.md using Gemini's translation via GitHub Actions.