# tonejs-json-sequencer

<p align="left">
  <a href="https://deepwiki.com/cat2151/tonejs-json-sequencer"><img src="https://img.shields.io/badge/DeepWiki-Documentation-blue?logo=book" alt="DeepWiki"></a>
  <a href="README.ja.md"><img src="https://img.shields.io/badge/üáØüáµ-Japanese-red.svg" alt="Japanese"></a>
  <a href="README.md"><img src="https://img.shields.io/badge/üá∫üá∏-English-blue.svg" alt="English"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/index.html"><img src="https://img.shields.io/badge/üöÄ-Live%20Demo-brightgreen.svg" alt="Demo"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/streaming.html"><img src="https://img.shields.io/badge/üéµ-Streaming%20Demo-orange.svg" alt="Streaming Demo"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/demo-library/"><img src="https://img.shields.io/badge/üì¶-Library%20Demo-blue.svg" alt="Library Demo"></a>
</p>

# Current Status
- Frequent breaking changes are expected.
- This document and related documentation contain AI-generated content, and plans may be incorrect (different from cat2151's original vision).

# Overview in 3 Lines
- A lightweight library that allows describing Tone.js timbres, effects, and performances in JSON.
- Control sound using data without writing code, enabling seamless integration with UI and streaming.
- Handle time-ordered events as data, allowing for intricate performance expressions.

# Why
- *This section was urgently generated by ChatGPT. It may be rewritten in the future.*
- *In reality, a large part of it is "to be implemented in the future."*

Tone.js is a library that enables rich musical expression on the web. It allows for advanced sound design, such as building synths, effect chains, and scheduling triggers, all freely in JavaScript.

However, due to its flexibility, timbre and pattern structures can become deeply embedded in the program, making reuse and integration difficult.

`tonejs-json-sequencer` is a small mechanism that leverages Tone.js while externalizing timbre definitions, performance content, and timing information as JSON, enabling data-driven music playback.

Sequences are structured like SMF, "explicitly listing all events in chronological order."

Timbres can be flexibly defined in JSON using Tone.js synth/chain/params.

Timbre parameters can be dynamically changed even during playback, allowing for performance expressions like delay vibrato and filter opening/closing.

It can directly receive NDJSON streams from external tools or live generation engines and play them in real-time.

This simplifies the process of manipulating, playing, and exchanging structured musical data via UI or network on Tone.js.

# Design Philosophy
- *This section was urgently generated by ChatGPT. It may be rewritten in the future.*

`tonejs-json-sequencer` adopts an approach where Tone.js components (synths, effect chains, parameter changes, etc.) are directly described in JSON.

It does not introduce unique music description languages or abstraction layers, delegating such high-level logic to higher program layers.

Timbre definitions specify constructor names like `Tone.Synth` or `Tone.FMSynth` and their argument objects.

Event definitions also have a structure similar to Tone.js calls like `triggerAttackRelease`.

Parameter changes during playback are listed as function names and arguments along with event timestamps.

This achieves the goal of making playback logic data-driven and configurable externally, without compromising the acoustic expressive power of Tone.js.

The core `scheduleOrExecuteEvent` is a simple source file that accepts a single element, with higher layers handling sequences and NDJSON streaming.

This allows for flexible and separate development of the low-level connection to Tone.js and higher-level concerns like sequencing and streaming.

# Using as a Library

`tonejs-json-sequencer` can be used as a library from other projects.

## Installation

### Using npm

```bash
npm install tonejs-json-sequencer tone
```

### Installing Directly from GitHub

You can install directly from GitHub to use the latest development version:

```bash
npm install cat2151/tonejs-json-sequencer tone
```

For a complete example of using the library from an external project via GitHub installation, refer to the [demo-library](https://cat2151.github.io/tonejs-json-sequencer/demo-library/) directory.

### Referencing `dist/` Directory Directly

You can clone or download this repository and directly reference the files in the `dist/` directory.

#### ES Modules (Recommended)

```javascript
import { SequencerNodes, playSequence } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

#### CommonJS

```javascript
const { SequencerNodes, playSequence } = require('./path/to/tonejs-json-sequencer/dist/cjs/index.js');
```

#### TypeScript

If you are using TypeScript, the type definition files are also included in the `dist/` directory:

```typescript
import { SequencerNodes, playSequence, SequenceEvent } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

Type definition file: `dist/index.d.ts`

### Using CDN

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

Or using unpkg:

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://unpkg.com/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

## Basic Usage Example

```typescript
import * as Tone from 'tone';
import { SequencerNodes, playSequence } from 'tonejs-json-sequencer';

// Define sequence in JSON
const sequence = [
  {
    eventType: 'createNode',
    nodeId: 0,
    nodeType: 'Synth',
    args: { oscillator: { type: 'sine' } }
  },
  {
    eventType: 'connect',
    nodeId: 0,
    connectTo: 'toDestination'
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['C4', '8n', '0']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['E4', '8n', '0:0:2']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['G4', '8n', '0:1:0']
  }
];

// Create node manager
const nodes = new SequencerNodes();

// Play sequence
async function play() {
  await Tone.start();
  await playSequence(Tone, nodes, sequence);
}

// Bind to button click
document.getElementById('playButton').addEventListener('click', play);
```

## Browser Usage Example (with CDN)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Tonejs JSON Sequencer Example</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@15.0.4/build/Tone.js"></script>
</head>
<body>
  <button id="playButton">Play</button>
  
  <script type="module">
    import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';

    const sequence = [
      {
        eventType: 'createNode',
        nodeId: 0,
        nodeType: 'Synth',
        args: { oscillator: { type: 'sine' } }
      },
      {
        eventType: 'connect',
        nodeId: 0,
        connectTo: 'toDestination'
      },
      {
        eventType: 'triggerAttackRelease',
        nodeId: 0,
        args: ['C4', '4n', '0']
      }
    ];

    const nodes = new SequencerNodes();

    document.getElementById('playButton').addEventListener('click', async () => {
      await Tone.start();
      await playSequence(Tone, nodes, sequence);
    });
  </script>
</body>
</html>
```

## `dist/` Directory Structure

The `dist/` directory contains the following files:

- `index.mjs` - Entry point in ES Modules format
- `index.js` - Entry point in CommonJS format
- `index.d.ts` - TypeScript type definition file
- `esm/` - Compiled files in ES Modules format
- `cjs/` - Compiled files in CommonJS format

You can choose the appropriate file format based on your project requirements.

## Examples

For more detailed usage examples, please refer to the `examples/` directory:

- `examples/cdn-example.html` - Browser usage example using CDN
- `examples/npm-example.mjs` - Usage example as an npm package

## NDJSON Streaming

`tonejs-json-sequencer` supports NDJSON (Newline Delimited JSON) streaming for real-time playback, live editing, and loop playback.

### Features

- **Live Editing**: Edit the sequence during playback ‚Äì changes are reflected in real-time without restarting.
- **Loop Playback**: Automatically loops when the sequence ends.
- **50ms Lookahead**: Events are scheduled 50ms in advance, ensuring smooth and accurate playback.

### Basic Usage

```typescript
import * as Tone from 'tone';
import { SequencerNodes, NDJSONStreamingPlayer } from 'tonejs-json-sequencer';

// Create node manager
const nodes = new SequencerNodes();

// Create streaming player with settings
const player = new NDJSONStreamingPlayer(Tone, nodes, {
  lookaheadMs: 50,    // Lookahead time (milliseconds)
  loop: true,         // Enable loop playback
  onLoopComplete: () => {
    console.log('Loop complete!');
  }
});

// Start playback with NDJSON string or event array
const ndjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["C4","8n","0"]}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["E4","8n","0:0:2"]}
`;

await Tone.start();
await player.start(ndjson);

// Update sequence during playback (live editing)
const updatedNdjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["G4","8n","0"]}
`;
await player.start(updatedNdjson);  // Update without stopping

// Stop playback
player.stop();
```

### Demo

For a complete interactive demo of live editing and loop playback, refer to `streaming.html`.

# JSON Support for Tone.js Components

`tonejs-json-sequencer` allows describing key Tone.js components in JSON.

## Support Status Overview

### Currently Supported (‚úÖ)

- **Instrument**: Synth, MonoSynth, FMSynth, AMSynth, DuoSynth, MetalSynth, MembraneSynth, PluckSynth, NoiseSynth, PolySynth, Sampler
- **Effect**: Reverb, Freeverb, JCReverb, Chorus, Phaser, Tremolo, Vibrato, AutoFilter, AutoPanner, AutoWah, FeedbackDelay, PingPongDelay, Distortion, BitCrusher, Chebyshev, PitchShift, FrequencyShifter, StereoWidener

### Planned (üöß)

- **Source**: FatOscillator, PulseOscillator
- **Effect**: EQ3 (Equalizer), Compressor
- **Performance Methods**: Panpot change, Expression change, LPF change, Portamento

### Under Consideration (‚è≥)

- **Source**: Oscillator, OmniOscillator, Noise, Player, GrainPlayer, etc.
- **Effect**: Filter series, Dynamics series (Limiter, Gate), Spatial series (Convolver), etc.
- **Component**: Envelope series, LFO, Signal series, Analysis series (Meter, Analyser, FFT), etc.

## Detailed Documentation

For detailed support status of all components, implementation priority, and implementation policy, please refer to the following document:

üìÑ [Tone.js Component JSON Support Roadmap (Detailed)](docs/tonejs-components-roadmap.ja.md)

This document includes the following information:
- Classification and implementation status of all components (Instrument / Source / Effect / Component)
- Implementation priorities and plans
- Implementation policy and approach
- Links to reference materials

# Roadmap for Unimplemented JSON Events

This section lists features that are "possible with Tone.js but not yet implemented as JSON events."

## Currently Implemented JSON Events

- `createNode` - Create synth or effect nodes
- `connect` - Connect nodes to each other
- `triggerAttackRelease` - Trigger note playback
- `depth.rampTo` - Smoothly change depth parameter
- `volume.rampTo` - Smoothly change volume parameter
- `LFO` - Create an LFO for the specified path and start modulation (start time is arbitrary, specified by Tone.Transport time)
- `set` - Global settings (currently only `Transport.bpm.value` is supported)
- `loopEnd` - Mark explicit loop boundaries for streaming playback (metadata event)

### LFO Event Example

```json
{
  "eventType": "LFO",
  "nodeId": 1,
  "args": [
    { "frequency": "4n", "min": 0, "max": 10, "type": "sine" },
    "filter.Q",
    "0:0:0"
  ]
}
```

## List of Unimplemented Features

### High Priority: JSON Events Required for Performance Expression

These are important features that directly impact performance expression.

#### Panpot (Panning) Control ‚è≥
- **Overview**: Change stereo position (L/R) in real-time
- **Required JSON Events**:
  - `pan.rampTo` - Smooth change of pan
  - `pan.value` - Immediate change of pan
- **Realization with Tone.js**: Control via Param API through corresponding nodes with a `.pan` parameter (e.g., `PanVol` / `Panner`)
- **Example Use**: Dynamically change L/R in a sequence phrase

#### LPF Cutoff Frequency and Resonance Control ‚è≥
- **Overview**: Change low-pass filter cutoff frequency and Q value in real-time
- **Required JSON Events**:
  - `filter.frequency.rampTo` - Smooth change of cutoff frequency
  - `filter.Q.rampTo` - Smooth change of resonance (Q value)
  - `filter.frequency.value` - Immediate change of cutoff frequency
  - `filter.Q.value` - Immediate change of resonance (Q value)
- **Realization with Tone.js**: Supported by synths with filters such as MonoSynth
- **Example Use**: Open/close filter within a phrase, long sweeps, attack-linked filter envelopes

#### Pitch Control (Portamento/Pitch Envelope) ‚è≥
- **Overview**: Smoothly change pitch
- **Required JSON Events**:
  - `frequency.rampTo` - Smooth change of frequency (portamento)
  - `detune.rampTo` - Smooth change of detune (pitch envelope)
- **Realization with Tone.js**: Frequency/detune parameters of oscillators and synths
- **Example Use**: Portamento, pitch envelope at attack (e.g., -200 cent to 0 cent)

#### Expression Control ‚è≥
- **Overview**: Dynamically control volume and other parameters
- **Required JSON Events**:
  - (Short term) Add individual events for main parameters like volume.
  - (Mid to long term) General parameter access mechanism.
  - Example: `<nodeId>.<paramPath>.rampTo` format (assuming `paramPath` itself is whitelisted and supported paths are enumerated).
- **Design Policy / Roadmap**:
  - Continue with the **node ID whitelist approach** using `switch-case`.
  - Even if `<nodeId>.<paramPath>.rampTo` is introduced, `paramPath` will **only allow predefined paths**, not arbitrary strings.
  - First, increase individual events and identify necessary patterns, then consider a general mechanism with enumerated supported paths.
- **Realization with Tone.js**: All Param objects support `rampTo`.
- **Example Use**: Increase/decrease expression within a phrase, changes in dynamics

### Medium Priority: Effect Parameter Control

#### Reverb Parameters ‚è≥
- **Required JSON Events**: `decay.rampTo`, `wet.rampTo`, etc.
- **Purpose**: Dynamically change reverb depth and room size.

#### Chorus Parameters ‚è≥
- **Required JSON Events**: `frequency.rampTo`, `depth.rampTo` (Chorus specific)
- **Purpose**: Dynamically change chorus speed and depth.

#### Delay Parameters ‚è≥
- **Required JSON Events**: `delayTime.rampTo`, `feedback.rampTo`, etc.
- **Purpose**: Dynamically change delay time and feedback amount.

#### Phaser Parameters ‚è≥
- **Required JSON Events**: `frequency.rampTo`, `octaves.rampTo`, `Q.rampTo`, etc.
- **Purpose**: Long phaser sweeps, modulation for pads.

#### EQ (Equalizer) Parameters ‚è≥
- **Required JSON Events**: `low.rampTo`, `mid.rampTo`, `high.rampTo`, etc.
- **Purpose**: Adjust levels for each frequency band.

#### Compressor Parameters ‚è≥
- **Required JSON Events**: `threshold.rampTo`, `ratio.rampTo`, `attack.rampTo`, `release.rampTo`, etc.
- **Purpose**: Dynamic adjustment of dynamics processing.

### Low Priority: Advanced Features

#### Envelope Control ‚è≥
- **Required JSON Events**: Access to ADSR parameters
- **Purpose**: Dynamic change of envelope shape

#### LFO Parameters ‚è≥
- **Required JSON Events**: Control of LFO frequency, depth, and waveform
- **Purpose**: Dynamic change of modulation

#### 3D Panning ‚è≥
- **Required JSON Events**: 3D spatial positioning control
- **Purpose**: Realization of spatial audio

## Implemented Features Check

### Tempo (BPM) Control ‚úÖ
- **Implementation Status**: ‚úÖ **Implemented**
- **JSON Event**: `set` event with `nodeType: 'Transport.bpm.value'`
- **Usage Example**:
  ```json
  {
    "eventType": "set",
    "nodeId": 0,
    "nodeType": "Transport.bpm.value",
    "args": [120]
  }
  ```

### Delay Vibrato ‚úÖ
- **Implementation Status**: ‚úÖ **Implemented**
- **Method**: Uses `depth.rampTo`

## Implementation Policy

1.  **Safety First**: Continue with the `switch-case` whitelist approach, without using `eval` etc., for safety and simplicity.
2.  **Incremental Implementation**: Implement high-priority features sequentially.
3.  **Dogfooding**: Verify implemented features by using them in practice.

## References

- Detailed component support status: [Tone.js Component JSON Support Roadmap](docs/tonejs-components-roadmap.ja.md)
- Tone.js official documentation: https://tonejs.github.io/docs/

# Roadmap
- *Order is not fixed.*
- *Later, it would be good to split into two types: a simple sample focused on one topic for ease of use, and a practical sample combining multiple topics to highlight strengths.*
- Program
  - Done: NDJSON streaming with live editing and loop playback (see streaming.html)
- Structure
  - Done: Multitimbral, FM Bass, and Saw Chord
- Performance Techniques
  - Done: Delay vibrato
  - Pitch envelope: attack at -200 cents, then changing to 0 cents *note: not attack-linked, but independent like delay vibrato*
  - Sequence phrase that changes Panpot dynamically between L/R
  - Phrase that increases/decreases Expression dynamically
  - Phrase that increases/decreases LPF dynamically
- Effect
  - Reverb
  - Chorus
  - Delay
  - Phaser: Apply a long sweep to a synth pad; if not possible, state it in the title, etc.
  - EQ
  - Compressor
- Lead
  - Done: SuperSaw timbre (FatOscillator)
  - Distortion, ideally with Pluck for guitar
  - Overdrive-style WaveShaper settings, ideally with Pluck for guitar
  - Radical synth lead using Chebyshev
  - Long decay FM lead with harmonic changes, typical shimmering FM lead; try pulse for modulator and carrier; if not possible, state it in the title, etc.
  - Ambient lead, pulse timbre, slightly random pitch fluctuations
  - Peculiar lead with attack-linked pitch envelope, -200 cents at attack, then changing to 0 cents
  - Lead with constant portamento
- Sequence Timbres
  - PulseOscillator timbre with 12.5% pulse
  - PluckSynth timbre for acoustic guitar or harp
  - Play a melodic phrase with NoiseSynth and a filter
- Drum
  - Tone.js built-in Kick, Snare, Tom, Hi-Hat; if 909 Kick is not possible, state it in the title, etc.
- Pad
  - Done: Thick synth pad with FatOscillator
  - FM Electric Piano
- Bass
  - Hard FM bass
  - Synth bass with constant attack-linked filter envelope
  - Overdrive-style Saw synth bass, with filter envelope, and a long filter sweep
- Add other notable Tone.js samples that clearly demonstrate sound as they are found. The above list completes the current phase.

# Development Notes (Continuously Updated)
- Integration with `tonejs-mml-to-json`
  - Postponed. Will consider after organizing the verification data for `tonejs-json-sequencer`.
- NDJSON streaming
  - Status: ‚úÖ **Implemented** (See `streaming.html` and `src/ndjson-streaming.ts`)
  - Implemented features:
    - Live editing: When the textarea is edited, the performance continues, and edits are reflected without replaying.
    - Loop playback: When the end is reached, playback restarts from the beginning.
    - 50ms lookahead: Events are scheduled 50ms in advance for smooth playback.
  - Implementation details:
    - `NDJSONStreamingPlayer` class processes events with lookahead timing.
    - Continuous event processing using `requestAnimationFrame`.
    - `parseNDJSON` function supports both arrays and NDJSON strings.
    - A dedicated demo and source file are located in `streaming.html`.
- `Tone.Transport.schedule` Not Yet Used
  - When I had an agent generate code for this, it produced complex code, but no improvement in playback naturalness was observed.
  - Decided it's premature; better to wait until test data is available.
  - Future Outlook:
    - Implement a higher layer (`tonejs-mml-to-json`).
    - Create test data.
      - JSON that clearly shows rhythmic instability.
        - E.g., high-tempo phrases with arpeggios, chords, and bass.
    - Execute the following:
      - Play that JSON with `tonejs-json-sequencer` and confirm the instability.
      - Implement `Tone.Transport.schedule` and test for instability improvement.
      - Implement and test the method successfully used in `postmate-midi`:
        - Process the time descriptions in JSON at a higher layer to specify real-time, then play with NDJSON streaming.
        - As mentioned, specify +50ms in the future.

# Issues Under Consideration
- Issue: Manually writing switch cases is cumbersome.
  - Policy: Writing direct function calls with switch-case is safe and simple, so this approach will generally be maintained.
    - Concern: If the switch-case grows too large in the future, there's a concern about communication speed being too high for a lightweight library.
      - Assumption: Therefore, also keep in mind the option of a mechanism that only uses whitelisted function names, though this would increase complexity and the risk of security errors.
        - Postponed: This is a non-functional requirement, so it's better to consider it after dogfooding and experiencing it as "too slow."
  - Analysis: Insufficient context for an agent to generate switch cases.
    - Example: Unclear if generation can cover `depth.rampTo` etc.
    - Example: Unclear if `depth.rampTo` is sufficient as is, or what other method chains exist for other performance techniques or timbres, requiring dogfooding.
    - Assumption: Even if generation could cover everything, investigating during test failures would be cumbersome (due to the large codebase).
  - Solution: Stick to the current implementation policy and proceed with dogfooding.
- Consideration of Sound Library
  - *May eventually be separated as a proposal for a separate project, similar to `tonejs-mml-to-json`.*
  - Previous Issues:
    - It's unclear what the full potential of Tone.js is in terms of sound when mastered.
      - "Mastering" here means within the scope of low-cost implementation, without external waveforms (soundfonts, etc.) or external AudioWorklets.
      - For example, for Saw and Square waves, the achievable sound character, presence of aliasing noise in high frequencies, and usefulness for FM connections are uninvestigated.
        - For reference, I asked ChatGPT (not verified, so take with a grain of salt), and it said Tone.js generates a waveform table for one loop during node creation, so aliasing noise appears around the Nyquist frequency for high frequencies.
      - For example, FM:
        - Since it uses frequency modulation instead of phase modulation and lacks feedback,
        - It cannot produce phase modulation or feedback-based timbres, but
        - The potential for what waveforms can be used for modulators and carriers, and what timbres can be produced, is still uninvestigated.
      - For example, SuperSaw:
        - It's unclear how much additional work, such as effects, is needed to achieve a practical, typical SuperSaw sound.
        - A clearer roadmap and workflow would be beneficial.
      - For example, to create a 1-loop, 64-sample, 8-bit waveform, there's no interface for it in Tone.js or Web Audio; presumably, the only way is to generate `partials` parameters via Fourier transform (if more is desired, external waveforms or AudioWorklets are the only options).
        - But it's still unclear if this is actually the case.
      - For example, Reverb / Chorus / Flanger / Phaser: It's still unclear if at least an SC-88Pro level can be achieved due to insufficient investigation.
      - For example, Distortion series, including Overdrive: It's still unclear if at least an SC-88Pro level can be achieved due to insufficient investigation.
      - Since the application is "using it with reservations, for education and experimentation," not being able to produce luxurious sounds is not critical.
        - The important point is that understanding "what is possible? Where is the sweet spot?" would facilitate smoother musical activities.
        - To clarify, Tone.js and WebAudio are positioned more towards simple signal processing than instruments. Given this, the perspective is: how much can be achieved instrumentally with low cost, accepting limitations?
        - "Low cost" here implies: if the technological stack and ecosystem for `tonejs-json-sequencer` become rich, can development be done at low cost by standing on the shoulders of giants?
        - It is understood that Tone.js is superior in overall capability among available options.
        - In other words, when choosing the browser as a free, open-source, multi-platform environment for musical activity, Tone.js is recognized as having superior overall capability.
  - Solution:
    - If sharing sound libraries becomes easy,
      - It will be easier to visualize "this is the potential that can be achieved with low-cost methods."
  - Image:
    - Share examples like "you can create these timbres," "you can apply these effects," and "combining them yields this level of practical sound."
  - Benefits of a Sound Library:
    - Expected to nurture the Tone.js ecosystem.
        - A past issue is the lack of reusability of users' outputs.
        - If an environment for sharing and integrating users' outputs is created, its accumulation can enable future users to stand on the shoulders of giants.
          - This applies not only to timbres but to Web Audio in general.
  - Consideration of the Sound Library's Layer:
    - Not to be integrated into `tonejs-json-sequencer`.
    - To be provided at a higher layer, as a separate project.
  - How much to focus on the Sound Library?
    - Under consideration.
    - If both the sound library and sound editor are well-developed, the ecosystem is likely to grow.
    - The priority for creating minimum functionality in `tonejs-json-sequencer` is high.
      - Because the existence of functionality in `tonejs-json-sequencer` is a prerequisite for higher layers.
- Related to "Why": Differentiating from DAWs
  - DAW
    - For when song completeness is prioritized.
    - For maximizing composition and arrangement efficiency.
    - Quickly create high-quality songs! Best practicality!
    - Required non-functional requirements: low latency, no audio dropouts. Assumes use of high-performance machines.
  - `tonejs-json-sequencer`
    - *Or rather, non-DAW music applications in browsers, WebAudio, Tone.js, multi-platform in general.*
    - For experimentation
      - New UI
      - New sounds, timbres, songs, using new methods
    - New experiences
      - Inspiration for composition
    - Interactive experiences
      - E.g., educational music toys
    - Required non-functional requirements: None.
      - Quick feature implementation is good.
      - Multi-platform is good.

# Priorities
- Implementing features with clear effects. E.g., delay vibrato, multitimbral.
- Safety. Security. Injection prevention. No `eval` or similar.

# Out of Scope
- Assigning `nodeId`s -> This will be handled by a higher layer, e.g., `tonejs-mml-to-json` or a lower-layer JSON post-processor.
- Generating delay vibrato on and off for all notes -> Same as `nodeId` assignment.
- Other data processing within JSON -> Same as `nodeId` assignment.
- Exhaustiveness. Completely covering all Tone.js classes, methods, and method chain combinations, and all possible function calls via JSON that can be achieved with Tone.js.
- High performance. Choosing hard-to-maintain logic to minimize processing time or source file size.

# Automated English Translation
`README.md` is automatically generated by GitHub Actions based on `README.ja.md` using Gemini's translation.