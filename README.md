# tonejs-json-sequencer

<p align="left">
  <a href="README.ja.md"><img src="https://img.shields.io/badge/üáØüáµ-Japanese-red.svg" alt="Japanese"></a>
  <a href="README.md"><img src="https://img.shields.io/badge/üá∫üá∏-English-blue.svg" alt="English"></a>
</p>

[Demo](https://cat2151.github.io/tonejs-json-sequencer/demo/index.html)

# Status
- Frequent breaking changes are planned.
- This document and related documents may contain AI-generated content, and plans may be incorrect (differing from cat2151's original concept).

# In Three Lines
- A lightweight library that allows defining Tone.js timbres, effects, and performances in JSON.
- Control sound with data without writing code, enabling seamless integration with UI and streaming.
- Handle time-ordered events as data, allowing for precise performance expressions.

# Why
- * This section was quickly generated by ChatGPT. It may be rewritten in the future.
- * In reality, most of this is "planned for future implementation."

Tone.js is a library that enables rich musical expression on the web. It allows for advanced sound design, such as building synths, effect chains, and scheduling triggers, all freely in JavaScript.

However, due to its flexibility, timbre and pattern structures can often become deeply embedded in the program, making reuse and integration difficult.

tonejs-json-sequencer is a small mechanism that leverages Tone.js while externalizing timbre definitions, performance content, and timing information as JSON, enabling data-driven music playback.

Sequences are structured like SMF (Standard MIDI File), explicitly arranging all events in chronological order.

Timbres can be flexibly defined in JSON using Tone.js's synth/chain/params.

Dynamic changes to timbre parameters during playback are possible, allowing for performance expressions like delayed vibrato or filter sweeps.

Directly accepts NDJSON streams from external tools or live generation engines for real-time playback.

This simply enables the manipulation, playback, and exchange of structured musical data via UI or over a network, all within Tone.js.

# Design Philosophy
- * This section was quickly generated by ChatGPT. It may be rewritten in the future.

tonejs-json-sequencer takes the approach of describing Tone.js components (synths, effect chains, parameter changes, etc.) directly in JSON.

It does not introduce its own music description language or abstraction layer, instead delegating such advanced logic to higher program layers.

Timbre definitions specify constructor names like Tone.Synth or Tone.FMSynth, along with argument objects.

Event definitions also have a structure similar to Tone.js calls, such as triggerAttackRelease.

Parameter changes during playback are listed with function names, arguments, and event timestamps.

This achieves the goal of moving playback logic into data, making it externally configurable, without compromising the sonic expressive power of Tone.js.

The core `scheduleOrExecuteEvent` is a simple source file that accepts a single element, with higher layers handling sequences and NDJSON streaming.

This allows for flexible, separate development of the low-level Tone.js interface and higher-level sequencing and streaming features.

# Using as a Library

tonejs-json-sequencer can be used as a library in other projects.

## Installation

### Using npm

```bash
npm install tonejs-json-sequencer tone
```

### Referencing the dist/ Directory Directly

You can clone or download this repository and directly reference the files in the `dist/` directory.

#### ES Modules (Recommended)

```javascript
import { SequencerNodes, playSequence } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

#### CommonJS

```javascript
const { SequencerNodes, playSequence } = require('./path/to/tonejs-json-sequencer/dist/cjs/index.js');
```

#### TypeScript

If you are using TypeScript, the type definition files are also included in the `dist/` directory:

```typescript
import { SequencerNodes, playSequence, SequenceEvent } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

Type definition file: `dist/index.d.ts`

### Using CDN

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

Or using unpkg:

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://unpkg.com/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

## Basic Usage Example

```typescript
import * as Tone from 'tone';
import { SequencerNodes, playSequence } from 'tonejs-json-sequencer';

// Define the sequence in JSON
const sequence = [
  {
    eventType: 'createNode',
    nodeId: 0,
    nodeType: 'Synth',
    args: { oscillator: { type: 'sine' } }
  },
  {
    eventType: 'connect',
    nodeId: 0,
    connectTo: 'toDestination'
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['C4', '8n', '0']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['E4', '8n', '0:0:2']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['G4', '8n', '0:1:0']
  }
];

// Create a node manager
const nodes = new SequencerNodes();

// Play the sequence
async function play() {
  await Tone.start();
  await playSequence(Tone, nodes, sequence);
}

// Attach to button click
document.getElementById('playButton').addEventListener('click', play);
```

## Browser Usage Example (using CDN)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Tonejs JSON Sequencer Example</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@15.0.4/build/Tone.js"></script>
</head>
<body>
  <button id="playButton">Play</button>
  
  <script type="module">
    import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';

    const sequence = [
      {
        eventType: 'createNode',
        nodeId: 0,
        nodeType: 'Synth',
        args: { oscillator: { type: 'sine' } }
      },
      {
        eventType: 'connect',
        nodeId: 0,
        connectTo: 'toDestination'
      },
      {
        eventType: 'triggerAttackRelease',
        nodeId: 0,
        args: ['C4', '4n', '0']
      }
    ];

    const nodes = new SequencerNodes();

    document.getElementById('playButton').addEventListener('click', async () => {
      await Tone.start();
      await playSequence(Tone, nodes, sequence);
    });
  </script>
</body>
</html>
```

## dist/ Directory Structure

The `dist/` directory contains the following files:

- `index.mjs` - ES Modules entry point
- `index.js` - CommonJS entry point
- `index.d.ts` - TypeScript type definition file
- `esm/` - Compiled files in ES Modules format
- `cjs/` - Compiled files in CommonJS format

You can choose the appropriate file format based on your project's requirements.

## Examples

For more detailed usage examples, please refer to the `examples/` directory:

- `examples/cdn-example.html` - Browser usage example using CDN
- `examples/npm-example.mjs` - Usage example as an npm package

# Tone.js Component JSON Compatibility

tonejs-json-sequencer enables major Tone.js components to be described in JSON.

## Compatibility Overview

### Currently Supported (‚úÖ)

- **Instrument**: Synth, MonoSynth, FMSynth, AMSynth, DuoSynth, MetalSynth, MembraneSynth, PluckSynth, NoiseSynth, PolySynth, Sampler
- **Effect**: Reverb, Freeverb, JCReverb, Chorus, Phaser, Tremolo, Vibrato, AutoFilter, AutoPanner, AutoWah, FeedbackDelay, PingPongDelay, Distortion, BitCrusher, Chebyshev, PitchShift, FrequencyShifter, StereoWidener

### Planned (üöß)

- **Source**: FatOscillator, PulseOscillator
- **Effect**: EQ3 (Equalizer), Compressor
- **Performance Techniques**: Panpot changes, Expression changes, LPF changes, Portamento

### Under Consideration (‚è≥)

- **Source**: Oscillator, OmniOscillator, Noise, Player, GrainPlayer, and others
- **Effect**: Filter effects, Dynamics (Limiter, Gate), Spatial effects (Convolver), and others
- **Component**: Envelope types, LFO, Signal types, Analysis types (Meter, Analyser, FFT), and others

## Detailed Documentation

For detailed compatibility status, implementation priorities, and policies for all components, please refer to the following document:

üìÑ [Tone.js Components JSON Compatibility Roadmap (Detailed Version)](docs/tonejs-components-roadmap.ja.md)

This document contains the following information:
- Classification and implementation status of all components (Instrument / Source / Effect / Component)
- Implementation priorities and plans
- Implementation policy and approach
- Links to reference materials

# Roadmap
- * Order not guaranteed
- * Later, it would be good to split into two types: simple samples focused on a single topic for ease of use, and practical samples combining multiple topics to showcase strengths.
- Program
  - NDJSON streaming, details to be described later
- Structure
  - Done : Multitimbral, FM Bass, and Saw Chord
- Performance Techniques
  - Done : Delayed vibrato
  - Pitch envelope: -200 cents at attack, then changes to 0 cents *independent of attack, like a delayed vibrato.*
  - Sequence phrase that changes Panpot LR on the fly.
  - Phrase that increases/decreases Expression on the fly.
  - Phrase that increases/decreases LPF on the fly.
- Effect
  - Reverb
  - Chorus
  - Delay
  - Phaser: apply a long sweep to a synth pad. If not possible, make it visible in the title etc.
  - EQ
  - Compressor
- Lead
  - Done : SuperSaw timbre (FatOscillator)
  - Distortion, preferably a guitar sound with Pluck.
  - Overdrive-like WaveShaper settings, preferably a guitar sound with Pluck.
  - Radical synth lead using Chebyshev.
  - FM lead with harmonic changes and long decay; typical shimmering FM lead; try pulse for modulator and carrier. If not possible, make it visible in the title etc.
  - Ambient lead: pulse timbre, subtly fluctuating pitch changes.
  - Distinctive lead: attack-linked pitch envelope, changing from -200 cents at attack to 0 cents.
  - Lead with constant portamento.
- Sequence Timbre
  - PulseOscillator timbre with 12.5% pulse.
  - PluckSynth timbre for acoustic guitar or harp.
  - NoiseSynth with a filter to play pitched phrases.
- Drum
  - Tone.js built-in Kick, Snare, Tom, Hi-Hat. If 909 Kick is not possible, make it visible in the title etc.
- Pad
  - Done : Thick synth pad with FatOscillator.
  - FM Electric Piano
- Bass
  - Hard FM bass.
  - Synth bass with a constant attack-linked filter envelope.
  - Overdrive-like Saw synth bass with filter envelope, and the filter changes with a long sweep.
- Other Tone.js samples that clearly demonstrate sounds will be added as notable ones are found. As of now, the above completes one phase.

# Development Notes (Continuously Updated)
- Integration with tonejs-mml-to-json
  - Postponed. Will be considered after organizing tonejs-json-sequencer's validation data.
- NDJSON streaming
  - Goals
    - Live editing: When a textarea is edited, the changes are reflected while playback continues, instead of restarting the performance.
    - Loop playback: When the end is reached, playback restarts from the beginning.
  - Method
    - NDJSON streaming for events to be played within the next 50msec.
    - Set 50msec after the 'play' button is pressed as 0-tick. Thereafter, the sequencer will process event times by adding +50msec. Further additions will be made during looping.
    - Expected to be split into a separate HTML file with a separate source.
- Do not use Tone.Transport.schedule yet.
  - When I tried having an agent generate code for it, complex code was produced, but no improvement in the unnaturalness of the sound was observed.
  - It is premature; it's better to wait until test data is available.
  - Future Outlook
    - Implement the higher layer (tonejs-mml-to-json).
    - Create test data.
      - JSON that clearly shows rhythm inconsistencies.
        - e.g., fast phrases with arpeggios, chords, and bass.
    - Perform the following:
      - Play that JSON with tonejs-json-sequencer and confirm the inconsistencies.
      - Implement Tone.Transport.schedule and test for inconsistency improvement.
      - Implement and test the proven method successful with postmate-midi:
        - Process JSON time descriptions in a higher layer to specify real-time, then play via NDJSON streaming.
        - As mentioned, specify +50msec in the future.

# Issues Under Consideration
- Issue: Manually writing switch-case statements is cumbersome.
  - Policy: Writing actual function calls with switch-case is safe and simple, so we generally intend to stick with this approach.
    - Concern: However, if the switch-case grows large in the future, there's a concern that it might incur too much communication overhead for a lightweight library concept.
      - Assumption: Therefore, a mechanism to only use function names from a whitelist should be considered as an option, though it would increase complexity and the risk of security errors.
        - Postponed: This is a non-functional requirement, so it's better to consider it after dogfooding reveals it's "too slow."
  - Analysis: Insufficient context for an agent to generate switch-case statements.
    - e.g., It's unclear if generation can cover things like depth.rampTo.
    - e.g., It needs dogfooding to determine if depth.rampTo is sufficient as is, and what other method chains exist for different performance techniques and timbres.
    - Assumption: Even if full coverage could be generated, investigating during test failures would be cumbersome (due to the large codebase).
  - Countermeasure: Continue with the current implementation policy and proceed with dogfooding.
- Consideration of a timbre library
  - * This might eventually be spun off as a separate project, similar to tonejs-mml-to-json.
  - Past Issues
    - It's unclear what the full potential of Tone.js is in terms of sound output when mastered.
      - Here, "mastered" means within the scope of low-cost implementation, without external waveforms (soundfonts, etc.) or external AudioWorklets.
      - For example, for Saw and Square, the actual timbre characteristics, presence of aliasing noise in high frequencies, and usefulness for FM connections are still unknown due to a lack of investigation.
        - (For reference, asking ChatGPT ‚Äî without verification ‚Äî it seems Tone.js generates a 1-loop waveform table upon node creation, and aliasing noise can appear around the Nyquist frequency at high frequencies.)
      - For example, FM:
        - Since it uses frequency modulation instead of phase modulation and lacks feedback,
        - it cannot produce phase modulation-based or feedback-based timbres, but
        - the potential for what waveforms can be used for modulators and carriers and what timbres can be produced is still unknown due to a lack of investigation.
      - For example, SuperSaw:
        - How much additional crafting, such as effects, is needed to
        - create a practical and typical SuperSaw?
        - A clearer roadmap and workflow would be beneficial.
      - For example, even if one wanted to create a 1-loop, 64-sample, 8-bit waveform, the Tone.js and Web Audio mechanisms lack a direct interface for this. It seems the only way is probably to generate `partials` parameters via Fourier transform (if more is needed, external waveforms or AudioWorklets are the only options), but
        - whether this is actually the case is still unknown due to a lack of investigation.
      - For example, for Reverb / Chorus / Flanger / Phaser, it's still unknown due to insufficient investigation whether at least SC-88Pro level quality can be achieved.
      - For example, for Distortion effects, including Overdrive, it's still unknown due to insufficient investigation whether at least SC-88Pro level quality can be achieved.
      - Since the intended use is "compromise. For educational and experimental purposes," the inability to produce luxurious sounds is not particularly critical.
        - What's important is to understand "what is achievable? Where is the sweet spot?" to enable smoother musical activity.
        - To elaborate, Tone.js and WebAudio are positioned more towards simple signal processing than musical instruments. Understanding this, there's also the perspective of how much instrument-like functionality can be achieved at low cost by making compromises.
        - "Low cost" here refers to the idea that "if the technology stack and ecosystem, like tonejs-json-sequencer, become richer, will it be possible to stand on the shoulders of giants and develop at a low cost in the future?"
        - It's recognized that Tone.js is superior in overall capabilities among the options.
        - In other words, when choosing the browser as a free, open-source, multi-platform environment for musical activities, Tone.js is perceived as superior in overall capabilities.
  - Countermeasures
    - If sharing timbre libraries becomes easy,
      - the potential that can be realized with low-cost methods is roughly this much.
      - This will become easier to visualize.
  - Image
    - Share examples such as: "These timbres can be created, these effects can be applied, and combined, these practical sounds can be achieved."
  - Benefits of a timbre library
    - It is expected to become the foundation of the Tone.js ecosystem.
        - A past issue has been the lack of reusability of each user's output.
        - If an environment for sharing and integrating each user's output can be established, its accumulation can help future users stand on the shoulders of giants.
          - This applies not only to timbres but also to Web Audio in general.
  - Consideration of the timbre library's layer
    - Not to be built into tonejs-json-sequencer, but
    - provided in a higher layer, as a separate project.
  - How much focus to put on the timbre library?
    - Under consideration
    - If both the timbre library and timbre editor are robust, the ecosystem is likely to grow more easily.
    - The priority for building minimum functionality into tonejs-json-sequencer is high.
      - Because the existence of functionality in tonejs-json-sequencer is a prerequisite for higher layers.
- Related to 'why': Differentiation from DAWs
  - DAW
    - For prioritizing song completeness.
    - For maximizing composition/arrangement efficiency.
    - High-quality songs can be created quickly! Supreme practicality!
    - Required non-functional app requirements: low latency, no audio dropouts. Assumes use of high-performance machines.
  - tonejs-json-sequencer
    - * Or more generally, non-DAW music apps for browsers, WebAudio, Tone.js, and multi-platform environments.
    - For experimentation
      - New UI
      - New sounds, timbres, and songs using new methods.
    - New experiences
      - Inspiration for composition.
    - Interactive experiences
      - e.g., educational music toys.
    - No specific non-functional requirements.
      - Quick feature implementation is desirable.
      - Multi-platform compatibility is desirable.

# Priorities
- Implementation of features with clear effects. For example, delayed vibrato, multitimbral.
- Safety. Security. Injection countermeasures. Avoid using eval, etc.

# Out of Scope
- nodeId numbering ‚Üí Handled by higher layers, e.g., tonejs-mml-to-json or a lower-layer JSON post-processor.
- Generating delayed vibrato on/off for all notes ‚Üí Similar to nodeId numbering.
- Other data processing within JSON ‚Üí Similar to nodeId numbering.
- Comprehensiveness: Fully covering all Tone.js classes, methods, method chain combinations, and all patterns of function calls achievable with Tone.js via JSON.
- High performance: Choosing hard-to-maintain logic to minimize processing time and source file size.

# Automatic Translation
README.md is automatically generated from README.ja.md using Gemini's translation via GitHub Actions.