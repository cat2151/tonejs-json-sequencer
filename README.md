# tonejs-json-sequencer

<p align="left">
  <a href="https://deepwiki.com/cat2151/tonejs-json-sequencer"><img src="https://img.shields.io/badge/DeepWiki-Documentation-blue?logo=book" alt="DeepWiki"></a>
  <a href="README.ja.md"><img src="https://img.shields.io/badge/üáØüáµ-Japanese-red.svg" alt="Japanese"></a>
  <a href="README.md"><img src="https://img.shields.io/badge/üá∫üá∏-English-blue.svg" alt="English"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/index.html"><img src="https://img.shields.io/badge/üöÄ-Live%20Demo-brightgreen.svg" alt="Demo"></a>
  <a href="https://cat2151.github.io/tonejs-json-sequencer/streaming.html"><img src="https://img.shields.io/badge/üéµ-Streaming%20Demo-orange.svg" alt="Streaming Demo"></a>
</p>

# Current Status
- Expect frequent breaking changes.
- This document and related documents may contain AI-generated content, and plans may be incorrect (differ from cat2151's original concept).

# Summary in 3 Lines
- A lightweight library that allows describing Tone.js timbres, effects, and performances in JSON.
- Control sound with data, not code, enabling seamless integration with UIs and streaming.
- Treating time-ordered events as data allows for precise musical expression.

# Why
- ‚ÄªTemporarily generated by ChatGPT. This section may be rewritten in the future.
- ‚ÄªIn fact, much of this is "planned for future implementation."

Tone.js is a library that enables rich musical expression on the web. It allows for advanced sound design, such as building synthesizers, effect chains, and scheduling triggers, all freely in JavaScript.

However, due to its flexibility, timbre and pattern structures can become deeply embedded in the program, making reuse and integration difficult.

`tonejs-json-sequencer` is a small mechanism that leverages Tone.js while externalizing timbre definitions, performance content, and timing information as JSON, enabling data-driven music playback.

The sequence structure is like SMF, explicitly arranging all events in chronological order.

Timbres can be flexibly defined in JSON using Tone.js's synth/chain/params.

Dynamic modification of timbre parameters during playback allows for expressive playing techniques such as delay vibrato and filter opening/closing.

It can directly receive NDJSON streams from external tools or live generation engines for real-time playback.

This enables a simple realization of operating, playing, and exchanging structured music data via UI or networks on Tone.js.

# Design Philosophy
- ‚ÄªTemporarily generated by ChatGPT. This section may be rewritten in the future.

`tonejs-json-sequencer` takes the approach of describing Tone.js components (synths, effect chains, parameter changes, etc.) directly in JSON.

It does not introduce its own music description language or abstraction layers; instead, such high-level logic is entrusted to higher program layers.

Timbre definitions specify constructor names like `Tone.Synth` or `Tone.FMSynth` and their argument objects.

Event definitions also have a structure similar to Tone.js calls, such as `triggerAttackRelease`.

Parameter changes during playback are listed as function names and arguments along with event timestamps.

This achieves the goal of shifting playback logic to data, making it externally configurable, without compromising Tone.js's sound expression capabilities.

The core `scheduleOrExecuteEvent` is a simple source file that accepts a single element, with higher layers handling sequences and NDJSON streaming.

This allows for flexible development by separating the low-level layer connected to Tone.js from higher-level layers like sequencing and streaming.

# Using as a Library

`tonejs-json-sequencer` can be used as a library in other projects.

## Installation

### Using npm

```bash
npm install tonejs-json-sequencer tone
```

### Directly referencing the `dist/` directory

You can clone or download this repository and directly reference the files in the `dist/` directory.

#### ES Modules (Recommended)

```javascript
import { SequencerNodes, playSequence } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

#### CommonJS

```javascript
const { SequencerNodes, playSequence } = require('./path/to/tonejs-json-sequencer/dist/cjs/index.js');
```

#### TypeScript

If you are using TypeScript, type definition files are also included in the `dist/` directory:

```typescript
import { SequencerNodes, playSequence, SequenceEvent } from './path/to/tonejs-json-sequencer/dist/index.mjs';
```

Type definition file: `dist/index.d.ts`

### Using a CDN

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

Or using unpkg:

```html
<script type="module">
  import { SequencerNodes, playSequence } from 'https://unpkg.com/tonejs-json-sequencer@1.0.0/dist/index.mjs';
</script>
```

## Basic Usage Example

```typescript
import * as Tone from 'tone';
import { SequencerNodes, playSequence } from 'tonejs-json-sequencer';

// Define sequence in JSON
const sequence = [
  {
    eventType: 'createNode',
    nodeId: 0,
    nodeType: 'Synth',
    args: { oscillator: { type: 'sine' } }
  },
  {
    eventType: 'connect',
    nodeId: 0,
    connectTo: 'toDestination'
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['C4', '8n', '0']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['E4', '8n', '0:0:2']
  },
  {
    eventType: 'triggerAttackRelease',
    nodeId: 0,
    args: ['G4', '8n', '0:1:0']
  }
];

// Create a node manager
const nodes = new SequencerNodes();

// Play the sequence
async function play() {
  await Tone.start();
  await playSequence(Tone, nodes, sequence);
}

// Attach to button click
document.getElementById('playButton').addEventListener('click', play);
```

## Browser Usage Example (using CDN)

```html
<!DOCTYPE html>
<html>
<head>
  <title>Tonejs JSON Sequencer Example</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@15.0.4/build/Tone.js"></script>
</head>
<body>
  <button id="playButton">Play</button>
  
  <script type="module">
    import { SequencerNodes, playSequence } from 'https://cdn.jsdelivr.net/npm/tonejs-json-sequencer@1.0.0/dist/index.mjs';

    const sequence = [
      {
        eventType: 'createNode',
        nodeId: 0,
        nodeType: 'Synth',
        args: { oscillator: { type: 'sine' } }
      },
      {
        eventType: 'connect',
        nodeId: 0,
        connectTo: 'toDestination'
      },
      {
        eventType: 'triggerAttackRelease',
        nodeId: 0,
        args: ['C4', '4n', '0']
      }
    ];

    const nodes = new SequencerNodes();

    document.getElementById('playButton').addEventListener('click', async () => {
      await Tone.start();
      await playSequence(Tone, nodes, sequence);
    });
  </script>
</body>
</html>
```

## `dist/` Directory Structure

The `dist/` directory contains the following files:

- `index.mjs` - Entry point for ES Modules
- `index.js` - Entry point for CommonJS
- `index.d.ts` - TypeScript type definition file
- `esm/` - Compiled files in ES Modules format
- `cjs/` - Compiled files in CommonJS format

You can choose the appropriate file format based on your project requirements.

## Samples

For more detailed usage examples, please refer to the `examples/` directory:

- `examples/cdn-example.html` - Browser usage example with CDN
- `examples/npm-example.mjs` - Usage example as an npm package

## NDJSON Streaming

`tonejs-json-sequencer` supports NDJSON (Newline Delimited JSON) streaming for real-time playback, live editing, and loop playback.

### Features

- **Live Editing**: Edit the sequence during playback ‚Äî changes are reflected in real-time without restarting.
- **Loop Playback**: The sequence automatically loops when it finishes.
- **50ms Lookahead**: Events are scheduled 50ms in advance for smooth and accurate playback.

### Basic Usage

```typescript
import * as Tone from 'tone';
import { SequencerNodes, NDJSONStreamingPlayer } from 'tonejs-json-sequencer';

// Create a node manager
const nodes = new SequencerNodes();

// Create a streaming player with settings
const player = new NDJSONStreamingPlayer(Tone, nodes, {
  lookaheadMs: 50,    // Lookahead time (milliseconds)
  loop: true,         // Enable loop playback
  onLoopComplete: () => {
    console.log('Loop complete!');
  }
});

// Start playback with an NDJSON string or an array of events
const ndjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["C4","8n","0"]}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["E4","8n","0:0:2"]}
`;

await Tone.start();
await player.start(ndjson);

// Update sequence during playback (live editing)
const updatedNdjson = `
{"eventType":"createNode","nodeId":0,"nodeType":"Synth"}
{"eventType":"connect","nodeId":0,"connectTo":"toDestination"}
{"eventType":"triggerAttackRelease","nodeId":0,"args":["G4","8n","0"]}
`;
await player.start(updatedNdjson);  // Update without stopping

// Stop playback
player.stop();
```

### Demo

For a full interactive demo of live editing and loop playback, please refer to `streaming.html`.

# JSON Support for Tone.js Components

`tonejs-json-sequencer` allows Tone.js's main components to be described in JSON.

## Overview of Support Status

### Currently Supported (‚úÖ)

- **Instrument**: Synth, MonoSynth, FMSynth, AMSynth, DuoSynth, MetalSynth, MembraneSynth, PluckSynth, NoiseSynth, PolySynth, Sampler
- **Effect**: Reverb, Freeverb, JCReverb, Chorus, Phaser, Tremolo, Vibrato, AutoFilter, AutoPanner, AutoWah, FeedbackDelay, PingPongDelay, Distortion, BitCrusher, Chebyshev, PitchShift, FrequencyShifter, StereoWidener

### Planned (üöß)

- **Source**: FatOscillator, PulseOscillator
- **Effect**: EQ3 (Equalizer), Compressor
- **Articulation Methods**: Panpot change, Expression change, LPF change, Portamento

### Under Future Consideration (‚è≥)

- **Source**: Oscillator, OmniOscillator, Noise, Player, GrainPlayer, etc.
- **Effect**: Filter series, Dynamics series (Limiter, Gate), Spatial series (Convolver), etc.
- **Component**: Envelope series, LFO, Signal series, Analysis series (Meter, Analyser, FFT), etc.

## Detailed Documentation

For detailed support status, implementation priorities, and policies for all components, please refer to the following document:

üìÑ [Tone.js Component JSON Support Roadmap (Detailed)](docs/tonejs-components-roadmap.ja.md)

This document includes the following information:
- Classification and implementation status of all components (Instrument / Source / Effect / Component)
- Implementation priorities and plans
- Implementation policies and procedures
- Links to reference materials

# Roadmap for Unimplemented JSON Events

This section lists features that are possible with Tone.js but not yet implemented as JSON events.

## Currently Implemented JSON Events

- `createNode` - Create synth or effect nodes
- `connect` - Connect nodes
- `triggerAttackRelease` - Trigger note playback
- `depth.rampTo` - Smoothly change the `depth` parameter
- `volume.rampTo` - Smoothly change the `volume` parameter
- `set` - Global settings (currently only supports `Transport.bpm.value`)
- `loopEnd` - Explicit loop boundary marker for streaming playback (metadata event)

## List of Unimplemented Features

### High Priority: JSON Events Required for Articulation Expression

These are important features that directly impact performance expression.

#### Panpot (Panning) Control ‚è≥
- **Overview**: Change stereo position (L/R) in real-time.
- **Required JSON Events**:
  - `pan.rampTo` - Smooth change of pan
  - `pan.value` - Immediate change of pan
- **Tone.js Implementation**: Controlled via `PanVol` / `Panner` or other corresponding nodes with a `.pan` parameter, using the Param API.
- **Example Use Case**: Dynamically vary L/R in a sequence phrase.

#### LPF Cutoff Frequency and Resonance Control ‚è≥
- **Overview**: Change low-pass filter cutoff frequency and Q value in real-time.
- **Required JSON Events**:
  - `filter.frequency.rampTo` - Smooth change of cutoff frequency
  - `filter.Q.rampTo` - Smooth change of resonance (Q value)
  - `filter.frequency.value` - Immediate change of cutoff frequency
  - `filter.Q.value` - Immediate change of resonance (Q value)
- **Tone.js Implementation**: Supported by synths with filters like MonoSynth.
- **Example Use Case**: Filter opening/closing in a phrase, long sweeps, attack-linked filter envelopes.

#### Pitch Control (Portamento/Pitch Envelope) ‚è≥
- **Overview**: Smoothly change pitch.
- **Required JSON Events**:
  - `frequency.rampTo` - Smooth change of frequency (portamento)
  - `detune.rampTo` - Smooth change of detune (pitch envelope)
- **Tone.js Implementation**: Frequency/detune parameters of oscillators and synths.
- **Example Use Case**: Portamento, pitch envelope during attack (-200 cents to 0 cents, etc.).

#### Expression Control ‚è≥
- **Overview**: Dynamically control volume and other parameters.
- **Required JSON Events**:
  - (Short-term) Add individual events for major parameters like volume.
  - (Mid- to long-term) Generic parameter access mechanism.
  - Example: `<nodeId>.<paramPath>.rampTo` format (assuming `paramPath` itself is whitelisted and supported paths are enumerated).
- **Design Policy / Roadmap**:
  - Continue the **node ID whitelist approach** using switch-case.
  - Even if `<nodeId>.<paramPath>.rampTo` is introduced, `paramPath` will not be an arbitrary string but **only predefined paths will be allowed**.
  - First, increase individual events, identify necessary patterns, and then consider a generic mechanism with enumerated supported paths.
- **Tone.js Implementation**: All Param objects support `rampTo`.
- **Example Use Case**: Increase/decrease expression in a phrase, dynamic changes.

### Medium Priority: Effect Parameter Control

#### Reverb Parameters ‚è≥
- **Required JSON Events**: `decay.rampTo`, `wet.rampTo`, etc.
- **Use Case**: Dynamically change reverb depth or room size.

#### Chorus Parameters ‚è≥
- **Required JSON Events**: `frequency.rampTo`, `depth.rampTo` (Chorus specific)
- **Use Case**: Dynamically change chorus speed or depth.

#### Delay Parameters ‚è≥
- **Required JSON Events**: `delayTime.rampTo`, `feedback.rampTo`, etc.
- **Use Case**: Dynamically change delay time or feedback amount.

#### Phaser Parameters ‚è≥
- **Required JSON Events**: `frequency.rampTo`, `octaves.rampTo`, `Q.rampTo`, etc.
- **Use Case**: Long phaser sweeps, modulation for pads.

#### EQ (Equalizer) Parameters ‚è≥
- **Required JSON Events**: `low.rampTo`, `mid.rampTo`, `high.rampTo`, etc.
- **Use Case**: Level adjustment for each frequency band.

#### Compressor Parameters ‚è≥
- **Required JSON Events**: `threshold.rampTo`, `ratio.rampTo`, `attack.rampTo`, `release.rampTo`, etc.
- **Use Case**: Dynamic adjustment of dynamics processing.

### Low Priority: Advanced Features

#### Envelope Control ‚è≥
- **Required JSON Events**: Access to ADSR parameters.
- **Use Case**: Dynamic changes to envelope shape.

#### LFO Parameters ‚è≥
- **Required JSON Events**: Control of LFO frequency, depth, and waveform.
- **Use Case**: Dynamic modulation changes.

#### 3D Panning ‚è≥
- **Required JSON Events**: 3D spatial positioning control.
- **Use Case**: Spatial audio implementation.

## Verification of Implemented Features

### Tempo (BPM) Control ‚úÖ
- **Implementation Status**: ‚úÖ **Implemented**
- **JSON Event**: `set` event with `nodeType: 'Transport.bpm.value'`
- **Example Usage**:
  ```json
  {
    "eventType": "set",
    "nodeId": 0,
    "nodeType": "Transport.bpm.value",
    "args": [120]
  }
  ```

### Delay Vibrato ‚úÖ
- **Implementation Status**: ‚úÖ **Implemented**
- **Method**: Uses `depth.rampTo`

## Implementation Policy

1.  **Safety First**: Continue using the whitelist approach with switch-case, avoiding `eval` etc.
2.  **Phased Implementation**: Implement features incrementally, starting with high priority.
3.  **Dogfooding**: Verify implemented features by actually using them.

## Reference Information

- Detailed component support status: [Tone.js Component JSON Support Roadmap](docs/tonejs-components-roadmap.ja.md)
- Tone.js official documentation: https://tonejs.github.io/docs/

# Roadmap
- ‚ÄªOrder is not fixed.
- ‚ÄªLater, it would be good to split into two types: a simple sample focused on one topic for ease of use, and a practical sample combining multiple topics to highlight strengths.
- Program
  - Done: NDJSON streaming with live editing and loop playback (see streaming.html)
- Structure
  - Done: Multitimbral, FM Bass, and Saw Chord
- Articulation
  - Done: Delay Vibrato
  - Pitch envelope where attack is -200 cents, then changes to 0 cents ‚ÄªNot attack-linked, but independent like delay vibrato.
  - Sequence phrase that changes panpot between L/R dynamically.
  - Phrase that increases/decreases expression dynamically.
  - Phrase that increases/decreases LPF dynamically.
- Effect
  - Reverb
  - Chorus
  - Delay
  - Phaser: apply a long sweep to a synth pad; if not possible, make it clear in the title, etc.
  - EQ
  - Compressor
- Lead
  - Done: SuperSaw timbre (FatOscillator)
  - Distortion, preferably a guitar sound with Pluck.
  - Overdrive-style WaveShaper settings, preferably a guitar sound with Pluck.
  - Extreme synth lead using Chebyshev.
  - FM lead with long decay and harmonic changes, a typical sharp FM lead; try using pulse for modulator and carrier; if not possible, make it clear in the title, etc.
  - Ambient lead, pulse timbre, with slightly random fluctuating pitch changes.
  - Distinctive lead: attack-linked pitch envelope where attack is -200 cents, then changes to 0 cents.
  - Lead with constant portamento.
- Sequence Timbres
  - PulseOscillator timbre, 12.5% pulse.
  - PluckSynth timbre, acoustic guitar or harp.
  - NoiseSynth with filter to play a melodious phrase.
- Drum
  - Tone.js built-in Kick, Snare, Tom, Hi-Hat; if 909 Kick is not possible, make it clear in the title, etc.
- Pad
  - Done: Thick synth pad with FatOscillator
  - FM electric piano
- Bass
  - Hard FM bass
  - Synth bass with a constant attack-linked filter envelope.
  - Overdrive-style Saw synth bass, with a filter envelope and a long filter sweep.
- Other Tone.js samples that produce clear sounds will be added as found. The above list seems sufficient for now.

# Developer Notes, Continuously Updated
- Integration with tonejs-mml-to-json
  - Postpone. Consider after organizing `tonejs-json-sequencer` validation data.
- NDJSON streaming
  - Status: ‚úÖ **Implemented** (See `streaming.html` and `src/ndjson-streaming.ts`)
  - Implemented features:
    - Live editing: When editing the textarea, playback continues, and changes are reflected in real-time without restarting.
    - Loop playback: When the end is reached, playback restarts from the beginning.
    - 50ms lookahead: Events are scheduled 50ms in advance for smooth playback.
  - Implementation details:
    - `NDJSONStreamingPlayer` class processes events at lookahead timing.
    - Continuous event processing using `requestAnimationFrame`.
    - `parseNDJSON` function supports both arrays and NDJSON strings.
    - A dedicated demo and source file are located in `streaming.html`.
- Do not use `Tone.Transport.schedule` yet.
  - When I had an agent generate code for it, complex code was generated, but no improvement in the unnaturalness of the sound was observed.
  - I judge it to be premature; it's better to wait until test data is available.
  - Future outlook:
    - Implement a higher layer (`tonejs-mml-to-json`).
    - Create test data.
      - JSON that clearly shows rhythm inconsistencies.
        - E.g., high-tempo phrases with arpeggios, chords, and bass lines.
    - Perform the following:
      - Play that JSON with `tonejs-json-sequencer` and confirm inconsistencies.
      - Implement `Tone.Transport.schedule` and test for inconsistency improvement.
      - Implement and test the method successfully used by `postmate-midi`:
        - Process the time description in JSON at a higher layer to specify real-time, then play with NDJSON streaming.
        - As mentioned above, specify +50ms in the future.

# Issues Under Consideration
- Issue: Manually writing switch-cases is cumbersome.
  - Policy: Writing actual function calls with switch-cases is safe and simple, so we will generally stick to this.
    - Concern: However, if the switch-case grows large, there is a concern that it might become too slow for a lightweight library concept.
      - Assumption: Therefore, a mechanism that uses only whitelisted function names could be an option, but it would increase complexity and the risk of security errors.
        - Postpone: This is a non-functional requirement, so it's better to consider it after dogfooding reveals it's "too slow."
  - Analysis: Insufficient context for an agent to generate switch-cases.
    - Example: Unclear if `depth.rampTo` etc. can be fully covered by generation.
    - Example: Whether `depth.rampTo` is sufficient as is, and what other method chains exist for other articulations or timbres, requires dogfooding.
    - Assumption: Even if generation could cover everything, investigating during test red would be cumbersome (due to the vast codebase).
  - Solution: Continue with the current implementation policy and proceed with dogfooding.
- Consideration of a tone library
  - ‚ÄªEventually, this might be spun off as a separate project, similar to `tonejs-mml-to-json`.
  - Past issues:
    - It's unclear what the full potential of Tone.js is in terms of sound when used skillfully.
      - "Skillfully used" here means within the scope of low-cost implementation, without external waveforms (soundfonts, etc.) or external AudioWorklets.
      - For example, with Saw and Square waves, the actual sonic character, presence/absence of aliasing noise in high-frequency ranges, and usefulness for FM connections are yet to be investigated and understood.
        - (As a side note, ChatGPT indicated - though not verified - that Tone.js generates waveform tables for one loop during node creation, and aliasing noise can occur around the Nyquist frequency at high frequencies.)
      - For example, with FM:
        - Since it uses frequency modulation instead of phase modulation and lacks feedback,
        - It cannot produce phase modulation-based sounds or feedback-based sounds,
        - But the potential for what waveforms can be used for modulators and carriers, and what timbres can be produced, is yet to be investigated and understood.
      - For example, with SuperSaw:
        - How much additional crafting, such as effects, is needed to achieve a
        - Practically typical SuperSaw sound?
        - A clearer roadmap and workflow would be beneficial.
      - For example, to create a 1-loop, 64-sample, 8-bit waveform, Tone.js and Web Audio's mechanisms might not offer a direct interface, likely requiring Fourier transforms to generate `partials` parameters (anything more might require external waveforms or AudioWorklets).
        - Whether this is actually the case is yet to be investigated and understood.
      - For example, with Reverb / Chorus / Flanger / Phaser, it's unclear if at least the SC-88Pro level can be achieved, due to insufficient investigation.
      - For example, with Distortion / Overdrive, it's unclear if at least the SC-88Pro level can be achieved, due to insufficient investigation.
      - The use case is "use with limitations; for educational and experimental purposes," so not being able to produce luxurious sounds is not critical.
        - The important point is that seeing "what can be achieved? where is the sweet spot?" would enable smoother musical activities.
        - To elaborate, Tone.js and WebAudio are positioned more towards simple signal processing than instruments. Understanding this, the perspective is: how much can be achieved instrumentally with a low-cost approach?
        - "Low-cost" here means "if the technological stack and ecosystem soil, like `tonejs-json-sequencer`, become rich, can development be done at low cost by standing on the shoulders of giants?"
        - It is recognized that Tone.js excels in overall capability among available options.
        - In other words, when choosing the browser as a free, open-source, multi-platform environment for music activities, Tone.js is recognized for its overall capability.
  - Solution:
    - If a tone library can be easily shared,
      - The potential that can be demonstrated with low-cost methods
      - will become more visible.
  - Image:
    - Share examples such as: "You can create these timbres," "You can apply these effects," and "By combining them, you can achieve this practical sound."
  - Benefits of a tone library:
    - It can be expected to become the foundation of the Tone.js ecosystem.
        - A past challenge has been the lack of reusability of each user's output.
        - If a foundation for sharing and collaborating on each user's output can be established, its accumulation can enable future users to stand on the shoulders of giants.
          - This applies not only to timbres but to Web Audio in general.
  - Consideration of the tone library's layer:
    - Do not integrate it into `tonejs-json-sequencer`.
    - Provide it at a higher layer, in a separate project.
  - How much to focus on the tone library?
    - Under consideration.
    - If both the tone library and a tone editor are enriched, the ecosystem is likely to grow.
    - The priority for creating minimum functionality in `tonejs-json-sequencer` is high.
      - Because the functionality in `tonejs-json-sequencer` is a prerequisite for higher layers.
- Why-related: Distinction from DAWs
  - DAWs
    - For when song completion is prioritized.
    - For maximizing composition and arrangement efficiency.
    - Quickly create high-quality songs! Ultimate practicality!
    - Required non-functional requirements: low latency, no audio dropouts. Assumes use of high-performance machines.
  - `tonejs-json-sequencer`
    - ‚ÄªOr browsers, WebAudio, Tone.js, and non-DAW-like music applications in general across multiple platforms.
    - For experimentation:
      - New UIs
      - New sounds, timbres, and songs with new methods.
    - New experiences:
      - Inspiration for composition.
    - Interactive experiences:
      - E.g., educational music toys.
    - Required non-functional requirements: None.
      - Quick realization of features is good.
      - Multi-platform capability is good.

# Priorities
- Implementing features with clear effects, such as delay vibrato and multitimbral.
- Safety and security. Injection countermeasures. Avoiding `eval`, etc.

# Out of Scope
- Node ID assignment ‚Üí This will be handled by a higher layer, for example, `tonejs-mml-to-json` or a JSON post-processor at a lower layer.
- Generating delay vibrato on and off for all notes ‚Üí Same as node ID assignment.
- Other JSON data processing ‚Üí Same as node ID assignment.
- Exhaustiveness: Completely covering all Tone.js classes, methods, and method chain combinations, and all patterns of function calls achievable via JSON.
- High performance: Choosing difficult-to-maintain logic to minimize processing time or source file size.

# Automatic English Translation
README.md is automatically generated from README.ja.md using Gemini's translation via GitHub Actions.